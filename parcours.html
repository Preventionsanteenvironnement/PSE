<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Parcours d entrainement PSE</title>
  <style>
    :root {
      --bg: #081127;
      --panel: #0f1d3a;
      --panel-2: #13264a;
      --line: #2b3f67;
      --text: #e5eefc;
      --muted: #9eb0d2;
      --accent: #38bdf8;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --violet: #8b5cf6;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      background: radial-gradient(1200px 600px at 10% -20%, #1b3d80 0%, transparent 60%),
                  radial-gradient(900px 500px at 110% 10%, #27346d 0%, transparent 65%),
                  var(--bg);
      color: var(--text);
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      padding: 14px;
    }

    .wrap {
      max-width: 1100px;
      margin: 0 auto;
      display: grid;
      gap: 12px;
    }

    .card {
      background: linear-gradient(180deg, rgba(19, 38, 74, 0.95), rgba(15, 29, 58, 0.98));
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px;
    }

    h1, h2, h3 { margin: 0; }

    .head {
      display: grid;
      gap: 8px;
    }

    .title {
      display: flex;
      justify-content: space-between;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .badge {
      border-radius: 999px;
      padding: 4px 10px;
      border: 1px solid #3f5a86;
      background: rgba(8, 17, 39, 0.5);
      color: #dbeafe;
      font-size: 0.72rem;
      font-weight: 700;
    }

    .meta {
      color: var(--muted);
      font-size: 0.85rem;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .progress-bar {
      height: 10px;
      border-radius: 999px;
      background: #0a1630;
      border: 1px solid #24395f;
      overflow: hidden;
      margin-top: 8px;
    }

    .progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #0ea5e9, #22c55e);
      transition: width 0.3s ease;
    }

    .progress-caption {
      margin-top: 5px;
      font-size: 0.78rem;
      color: var(--muted);
    }

    .steps {
      display: grid;
      gap: 8px;
      grid-template-columns: repeat(auto-fit, minmax(190px, 1fr));
    }

    .step {
      border: 1px solid #2f446b;
      border-radius: 12px;
      padding: 10px;
      background: #0b1733;
      cursor: pointer;
      transition: 0.2s ease;
    }

    .step:hover { border-color: #3f5f95; }

    .step.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .step.locked {
      opacity: 0.65;
      cursor: not-allowed;
    }

    .step.done {
      border-color: #16a34a;
      background: rgba(34, 197, 94, 0.14);
    }

    .step-title {
      font-size: 0.9rem;
      font-weight: 800;
      margin-bottom: 4px;
    }

    .step-meta {
      color: var(--muted);
      font-size: 0.72rem;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }

    .step-pill {
      border-radius: 999px;
      padding: 2px 8px;
      font-size: 0.68rem;
      border: 1px solid #395585;
      background: #0f1d3a;
      color: #dbeafe;
      font-weight: 700;
    }

    .step-pill.ok { border-color: #166534; background: #052e16; color: #bbf7d0; }
    .step-pill.fail { border-color: #92400e; background: #451a03; color: #fde68a; }
    .step-pill.lock { border-color: #475569; background: #0f172a; color: #cbd5e1; }

    .detail-head {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .detail-sub {
      color: var(--muted);
      font-size: 0.86rem;
      margin-bottom: 8px;
    }

    .blocks {
      display: grid;
      gap: 8px;
    }

    .block {
      border: 1px solid #2f446b;
      border-radius: 10px;
      padding: 10px;
      background: #09142d;
      display: grid;
      gap: 8px;
    }

    .block-title {
      font-size: 0.86rem;
      font-weight: 700;
    }

    .block-meta {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      color: var(--muted);
      font-size: 0.72rem;
    }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; }

    .btn,
    .btn-soft,
    .btn-danger,
    .btn-line {
      border: none;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 800;
      padding: 10px 12px;
      font-size: 0.85rem;
    }

    .btn {
      background: linear-gradient(90deg, #0ea5e9, #2563eb);
      color: #e0f2fe;
    }

    .btn:hover { filter: brightness(1.05); }

    .btn-soft {
      background: rgba(34, 197, 94, 0.18);
      color: #bbf7d0;
      border: 1px solid rgba(34, 197, 94, 0.45);
    }

    .btn-line {
      background: transparent;
      color: #dbeafe;
      border: 1px solid #3b527d;
    }

    .btn-danger {
      background: rgba(239, 68, 68, 0.15);
      color: #fecaca;
      border: 1px solid rgba(239, 68, 68, 0.4);
    }

    .actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 8px;
    }

    .alert {
      border: 1px solid rgba(245, 158, 11, 0.5);
      background: rgba(146, 64, 14, 0.2);
      color: #fde68a;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.82rem;
      margin-top: 8px;
    }

    .ok-box {
      border: 1px solid rgba(34, 197, 94, 0.45);
      background: rgba(22, 163, 74, 0.18);
      color: #bbf7d0;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.82rem;
      margin-top: 8px;
    }

    .danger-box {
      border: 1px solid rgba(239, 68, 68, 0.45);
      background: rgba(127, 29, 29, 0.25);
      color: #fecaca;
      border-radius: 10px;
      padding: 10px;
      font-size: 0.82rem;
      margin-top: 8px;
    }

    .completion-screen {
      text-align: center;
      padding: 40px 20px;
    }
    .completion-screen .completion-icon {
      font-size: 3rem;
      margin-bottom: 12px;
    }
    .completion-screen h3 {
      color: #22c55e;
      font-size: 1.3rem;
      margin: 0 0 10px;
    }
    .completion-screen p {
      color: #94a3b8;
      font-size: 0.9rem;
      margin: 4px 0;
    }

    .rem-list {
      margin-top: 8px;
      display: grid;
      gap: 8px;
    }

    .rem-item {
      border: 1px dashed #4b5f87;
      border-radius: 10px;
      padding: 9px;
      background: rgba(15, 29, 58, 0.45);
      display: grid;
      gap: 6px;
    }

    .small {
      font-size: 0.76rem;
      color: var(--muted);
    }

    .loader,
    .err {
      text-align: center;
      padding: 24px 10px;
      color: var(--muted);
    }

    .err { color: #fecaca; }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 16px;
      transform: translateX(-50%);
      background: #1d4ed8;
      color: #fff;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 10px;
      padding: 9px 12px;
      font-size: 0.82rem;
      font-weight: 700;
      display: none;
      max-width: min(90vw, 640px);
      text-align: center;
      z-index: 999;
    }

    @media (max-width: 700px) {
      body { padding: 10px; }
      .actions .btn,
      .actions .btn-soft,
      .actions .btn-danger,
      .actions .btn-line { width: 100%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <section class="card" id="head-card">
      <div class="loader" id="head-loader">Chargement du parcours...</div>
      <div id="head-content" style="display:none;" class="head">
        <div class="title">
          <h1 id="p-titre">Parcours</h1>
          <div style="display:flex; gap:6px; flex-wrap:wrap;">
            <span class="badge" id="p-module">Module</span>
            <span class="badge" id="p-niveau">Niveau</span>
            <span class="badge mono" id="p-code">Code</span>
          </div>
        </div>
        <div class="meta" id="p-desc"></div>
        <div class="progress-bar"><div class="progress-fill" id="global-progress"></div></div>
        <div class="progress-caption" id="global-caption"></div>
        <div class="actions">
          <button class="btn-line" id="btn-reset-session" type="button">Reinitialiser ma progression locale</button>
        </div>
      </div>
    </section>

    <section class="card" id="steps-card" style="display:none;">
      <h2 style="margin-bottom:8px;">Etapes du parcours</h2>
      <div class="steps" id="steps-grid"></div>
    </section>

    <section class="card" id="detail-card" style="display:none;">
      <div id="step-detail"></div>
    </section>

    <section class="card" id="autoeval-card" style="display:none;">
      <h2 style="margin-bottom:8px;">Autoevaluation</h2>
      <div class="detail-sub" id="ae-consigne"></div>
      <div class="actions">
        <button class="btn" id="btn-autoeval" type="button">Lancer l auto-evaluation</button>
        <button class="btn-soft" id="btn-ae-restart" type="button" style="display:none;">Recommencer l auto-evaluation</button>
        <button class="btn-line" id="btn-ae-send" type="button" style="display:none;">Envoyer l auto-evaluation</button>
        <button class="btn-line" id="btn-ae-back" type="button" style="display:none;">Retour au parcours</button>
      </div>
      <div id="ae-alert"></div>
      <div id="ae-last"></div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyAWdCMvOiAJln3eT9LIAQD3RWJUD0lQcLI",
      authDomain: "devoirs-pse.firebaseapp.com",
      projectId: "devoirs-pse",
      storageBucket: "devoirs-pse.firebasestorage.app",
      messagingSenderId: "614730413904",
      appId: "1:614730413904:web:a5dd478af5de30f6bede55"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const urlParams = new URLSearchParams(window.location.search);
    const parcoursId = (urlParams.get("id") || "").trim();

    let sessionCode = (urlParams.get("code") || localStorage.getItem("pse_parcours_code") || "").trim();
    if (!sessionCode) {
      sessionCode = "PRC-" + Math.random().toString(36).slice(2, 8).toUpperCase();
      localStorage.setItem("pse_parcours_code", sessionCode);
    }

    let parcours = null;
    let state = null;
    let activeStepIndex = 0;

    function esc(s) {
      return String(s == null ? "" : s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function deepClone(v) {
      return JSON.parse(JSON.stringify(v));
    }

    function now() { return Date.now(); }

    function showToast(msg, isErr = false) {
      const t = document.getElementById("toast");
      t.textContent = msg;
      t.style.display = "block";
      t.style.background = isErr ? "#991b1b" : "#1d4ed8";
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => { t.style.display = "none"; }, 2600);
    }

    function ensureParcoursShape(raw) {
      const base = {
        type: "parcours_progressif",
        titre: "Parcours",
        module: "",
        niveau: "cap",
        version: 1,
        description: "",
        regles: {
          mode_progression: "sequentiel",
          seuil_reussite_etape: 70,
          max_tentatives_par_exercice: 3,
          autoriser_saut_autoevaluation: true,
          autoriser_recommencer_autoevaluation: true,
          autoriser_envoyer_autoevaluation: true
        },
        competences_cibles: [],
        etapes: [],
        autoevaluation: {
          mode: "ref_existante",
          ref_autoeval_id: "",
          titre_bouton: "Lancer l auto-evaluation",
          consigne_prealable: "Vous pouvez lancer l auto-evaluation maintenant ou continuer a vous entrainer",
          conditions_suggerees: {
            score_moyen_parcours_recommande: 70,
            etapes_min_reussies: 1
          },
          feedback_fin: {
            si_reussite: "Bravo, vous pouvez envoyer.",
            si_echec: "Refaites des exercices puis retentez.",
            si_abandon: "Vous pouvez reprendre plus tard."
          }
        },
        ui: {
          couleurs_pastilles: true,
          afficher_progression_par_etape: true,
          afficher_score_global: true,
          afficher_conseils: true
        }
      };

      const p = {
        ...base,
        ...(raw || {}),
        regles: { ...base.regles, ...((raw || {}).regles || {}) },
        autoevaluation: {
          ...base.autoevaluation,
          ...((raw || {}).autoevaluation || {}),
          conditions_suggerees: {
            ...base.autoevaluation.conditions_suggerees,
            ...(((raw || {}).autoevaluation || {}).conditions_suggerees || {})
          },
          feedback_fin: {
            ...base.autoevaluation.feedback_fin,
            ...(((raw || {}).autoevaluation || {}).feedback_fin || {})
          }
        },
        ui: { ...base.ui, ...((raw || {}).ui || {}) }
      };

      if (!Array.isArray(p.etapes)) p.etapes = [];
      p.etapes = p.etapes.map((et, idx) => ({
        id: et.id || "E" + (idx + 1),
        titre: et.titre || ("Etape " + (idx + 1)),
        objectif: et.objectif || "",
        consigne: et.consigne || "",
        seuil_validation: Number.isFinite(Number(et.seuil_validation)) ? Math.max(0, Math.min(100, Math.round(Number(et.seuil_validation)))) : 70,
        blocs: Array.isArray(et.blocs) ? et.blocs.map((b, bi) => ({
          id: b.id || ("B" + (bi + 1)),
          type_bloc: "exercice_ref",
          ref_exercice_id: b.ref_exercice_id || "",
          label: b.label || "",
          poids: Number.isFinite(Number(b.poids)) ? Math.max(0, Number(b.poids)) : 1
        })) : [],
        remediation: {
          si_echec: Array.isArray((et.remediation || {}).si_echec)
            ? (et.remediation || {}).si_echec.map((r) => ({
              type_action: "proposer_exercice_ref",
              ref_exercice_id: r.ref_exercice_id || "",
              message: r.message || ""
            }))
            : [],
          feedback_global: (et.remediation || {}).feedback_global || ""
        }
      }));

      return p;
    }

    function storageKey() {
      return `pse_parcours_state_${parcoursId}_${sessionCode}`;
    }

    function buildInitialState() {
      const stepMap = {};
      (parcours.etapes || []).forEach((et) => {
        const blocks = {};
        (et.blocs || []).forEach((b) => {
          blocks[b.id] = { attempts: [] };
        });
        stepMap[et.id] = {
          blocks,
          score: 0,
          validated: false,
          updatedAt: now()
        };
      });

      return {
        sessionCode,
        parcoursId,
        startedAt: now(),
        updatedAt: now(),
        steps: stepMap,
        autoEval: {
          attempts: [],
          sent: false
        }
      };
    }

    function loadState() {
      const key = storageKey();
      let loaded = null;
      try {
        const raw = localStorage.getItem(key);
        if (raw) loaded = JSON.parse(raw);
      } catch (_) {}

      if (!loaded || typeof loaded !== "object") {
        state = buildInitialState();
        saveState();
        return;
      }

      state = buildInitialState();

      Object.keys(state.steps).forEach((sid) => {
        const incoming = loaded.steps && loaded.steps[sid] ? loaded.steps[sid] : null;
        if (!incoming) return;

        const localStep = state.steps[sid];
        Object.keys(localStep.blocks).forEach((bid) => {
          const arr = incoming.blocks && incoming.blocks[bid] && Array.isArray(incoming.blocks[bid].attempts)
            ? incoming.blocks[bid].attempts
            : [];
          localStep.blocks[bid].attempts = arr;
        });
      });

      if (loaded.autoEval && Array.isArray(loaded.autoEval.attempts)) {
        state.autoEval.attempts = loaded.autoEval.attempts;
        state.autoEval.sent = !!loaded.autoEval.sent;
      }

      recomputeAllStepScores();
      saveState();
    }

    function saveState() {
      state.updatedAt = now();
      localStorage.setItem(storageKey(), JSON.stringify(state));
    }

    function getStepState(stepId) {
      return state.steps[stepId];
    }

    function bestAttempt(attempts) {
      if (!attempts || !attempts.length) return null;
      return attempts.slice().sort((a, b) => (b.score_pct || 0) - (a.score_pct || 0))[0] || null;
    }

    function recomputeStepScore(stepId) {
      const et = (parcours.etapes || []).find((s) => s.id === stepId);
      const st = getStepState(stepId);
      if (!et || !st) return;

      let weightedScore = 0;
      let totalWeight = 0;
      let completedBlocks = 0;

      (et.blocs || []).forEach((b) => {
        const attempts = st.blocks[b.id]?.attempts || [];
        const best = bestAttempt(attempts);
        if (!best) return;
        const w = Number(b.poids || 1);
        weightedScore += (best.score_pct || 0) * w;
        totalWeight += w;
        completedBlocks += 1;
      });

      const score = totalWeight > 0 ? Math.round((weightedScore / totalWeight) * 10) / 10 : 0;
      st.score = score;

      const allBlocksDone = (et.blocs || []).every((b) => {
        const attempts = st.blocks[b.id]?.attempts || [];
        return attempts.length > 0;
      });

      st.validated = allBlocksDone && score >= Number(et.seuil_validation || 70);
      st.updatedAt = now();
    }

    function recomputeAllStepScores() {
      (parcours.etapes || []).forEach((et) => recomputeStepScore(et.id));
    }

    function isStepUnlocked(index) {
      if (index <= 0) return true;
      for (let i = 0; i < index; i += 1) {
        const sid = parcours.etapes[i].id;
        if (!state.steps[sid]?.validated) return false;
      }
      return true;
    }

    function totalValidatedSteps() {
      return (parcours.etapes || []).filter((et) => state.steps[et.id]?.validated).length;
    }

    function globalScore() {
      const etapes = parcours.etapes || [];
      if (!etapes.length) return 0;
      const total = etapes.reduce((acc, et) => acc + (state.steps[et.id]?.score || 0), 0);
      return Math.round((total / etapes.length) * 10) / 10;
    }

    function globalCompletionPercent() {
      const etapes = parcours.etapes || [];
      if (!etapes.length) return 0;
      return Math.round((totalValidatedSteps() / etapes.length) * 100);
    }

    function computeWeakSteps() {
      return (parcours.etapes || [])
        .map((et) => ({ id: et.id, titre: et.titre, score: state.steps[et.id]?.score || 0 }))
        .sort((a, b) => a.score - b.score)
        .slice(0, 2);
    }

    function chooseActiveStep() {
      if (!parcours.etapes.length) {
        activeStepIndex = 0;
        return;
      }
      const unlocked = parcours.etapes.findIndex((_, i) => isStepUnlocked(i) && !state.steps[parcours.etapes[i].id]?.validated);
      if (unlocked >= 0) {
        activeStepIndex = unlocked;
        return;
      }
      activeStepIndex = Math.max(0, parcours.etapes.length - 1);
    }

    function renderHeader() {
      document.getElementById("head-loader").style.display = "none";
      document.getElementById("head-content").style.display = "grid";
      document.getElementById("steps-card").style.display = "block";
      document.getElementById("detail-card").style.display = "block";
      document.getElementById("autoeval-card").style.display = "block";

      document.getElementById("p-titre").textContent = parcours.titre || "Parcours";
      document.getElementById("p-module").textContent = "Module: " + (parcours.module || "-");
      document.getElementById("p-niveau").textContent = "Niveau: " + (parcours.niveau || "-");
      document.getElementById("p-code").textContent = sessionCode;
      document.getElementById("p-desc").textContent = parcours.description || "Parcours progressif d entrainement.";

      const pct = globalCompletionPercent();
      document.getElementById("global-progress").style.width = pct + "%";
      document.getElementById("global-caption").textContent = `${totalValidatedSteps()} / ${(parcours.etapes || []).length} etape(s) validee(s) - Score global ${globalScore()}%`;
    }

    function renderStepsGrid() {
      const host = document.getElementById("steps-grid");
      host.innerHTML = (parcours.etapes || []).map((et, idx) => {
        const st = state.steps[et.id];
        const unlocked = isStepUnlocked(idx);
        const done = !!st?.validated;
        const active = idx === activeStepIndex;

        let pill = '<span class="step-pill lock">Verrouillee</span>';
        if (unlocked && done) pill = `<span class="step-pill ok">Validee ${st.score}%</span>`;
        else if (unlocked) pill = `<span class="step-pill fail">En cours ${st.score}%</span>`;

        return `<article class="step ${active ? "active" : ""} ${done ? "done" : ""} ${unlocked ? "" : "locked"}" data-step-index="${idx}">
          <div class="step-title">${esc(et.titre || et.id)}</div>
          <div class="step-meta">
            <span>${esc(et.id)}</span>
            <span>Seuil ${esc(et.seuil_validation)}%</span>
          </div>
          <div style="margin-top:6px;">${pill}</div>
        </article>`;
      }).join("");
    }

    function getBlockAttemptCount(stepId, blockId) {
      return getStepState(stepId)?.blocks?.[blockId]?.attempts?.length || 0;
    }

    function getBlockBestScore(stepId, blockId) {
      const arr = getStepState(stepId)?.blocks?.[blockId]?.attempts || [];
      const best = bestAttempt(arr);
      return best ? Math.round(best.score_pct || 0) : null;
    }

    function renderStepDetail() {
      // Show completion screen when all steps are validated
      if (allStepsValidated() && (parcours.etapes || []).length > 0) {
        document.getElementById("step-detail").innerHTML = '<div class="completion-screen">'
          + '<div class="completion-icon">&#127881;</div>'
          + '<h3>Parcours termine !</h3>'
          + '<p>Vous avez valide toutes les etapes. Score global : ' + globalScore() + '%</p>'
          + '<p>Vous pouvez maintenant lancer l auto-evaluation ci-dessous.</p>'
          + '</div>';
        return;
      }

      const et = (parcours.etapes || [])[activeStepIndex];
      if (!et) {
        document.getElementById("step-detail").innerHTML = '<div class="err">Aucune etape.</div>';
        return;
      }

      const unlocked = isStepUnlocked(activeStepIndex);
      const st = getStepState(et.id);
      const maxAttempts = Number(parcours?.regles?.max_tentatives_par_exercice || 3);

      const blocksHtml = (et.blocs || []).map((b) => {
        const attempts = getBlockAttemptCount(et.id, b.id);
        const best = getBlockBestScore(et.id, b.id);
        const reachedMax = attempts >= maxAttempts;

        return `<div class="block">
          <div class="block-title">${esc(b.label || b.id)}</div>
          <div class="block-meta">
            <span class="badge mono">${esc(b.ref_exercice_id)}</span>
            <span class="badge">Poids ${esc(b.poids)}</span>
            <span class="badge">Tentatives ${attempts}/${maxAttempts}</span>
            <span class="badge">Meilleure ${best == null ? "-" : (best + "%")}</span>
          </div>
          <div class="actions">
            <button class="btn" type="button" data-run-block="${esc(b.id)}" ${(!unlocked || reachedMax || !b.ref_exercice_id) ? "disabled" : ""}>Lancer exercice</button>
          </div>
        </div>`;
      }).join("");

      const canGoNext = st?.validated;
      const stepFeedback = ((et.remediation || {}).feedback_global || "").trim();
      const allBlocksDone = (et.blocs || []).every((b) => getBlockAttemptCount(et.id, b.id) > 0);
      const showRem = unlocked && !st?.validated && allBlocksDone;

      let remediationHtml = "";
      if (showRem) {
        const remItems = ((et.remediation || {}).si_echec || []).filter((r) => r.ref_exercice_id);
        remediationHtml += '<div class="alert">Seuil non atteint. Remediation proposee avant de debloquer l etape suivante.</div>';
        remediationHtml += '<div class="rem-list">';
        remediationHtml += remItems.map((r, ri) => {
          return `<div class="rem-item">
            <div class="small">${esc(r.message || "Exercice de remediation")}</div>
            <div class="mono small">${esc(r.ref_exercice_id)}</div>
            <div class="actions">
              <button class="btn-soft" type="button" data-run-rem="${ri}" ${!unlocked ? "disabled" : ""}>Lancer remediation</button>
            </div>
          </div>`;
        }).join("");
        remediationHtml += '</div>';
      }

      let feedbackBox = "";
      if (stepFeedback) {
        feedbackBox = `<div class="ok-box">${esc(stepFeedback)}</div>`;
      }

      const lockNote = !unlocked
        ? '<div class="danger-box">Etape verrouillee: validez les etapes precedentes.</div>'
        : "";

      document.getElementById("step-detail").innerHTML = `
        <div class="detail-head">
          <div>
            <h3>${esc(et.titre || et.id)}</h3>
            <div class="detail-sub">Objectif: ${esc(et.objectif || "-")}</div>
          </div>
          <span class="step-pill ${st?.validated ? "ok" : "fail"}">Score etape ${st?.score || 0}% (seuil ${et.seuil_validation}%)</span>
        </div>
        <div class="detail-sub">${esc(et.consigne || "")}</div>
        ${lockNote}
        <div class="blocks">${blocksHtml}</div>
        ${feedbackBox}
        ${remediationHtml}
        <div class="actions">
          <button class="btn-line" type="button" id="btn-next-step" ${canGoNext ? "" : "disabled"}>Continuer</button>
        </div>
      `;

      // Event listeners handled via delegation in bindUIEvents()
    }

    function renderAutoEvalCard() {
      const ae = parcours.autoevaluation || {};
      const btn = document.getElementById("btn-autoeval");
      btn.textContent = ae.titre_bouton || "Lancer l auto-evaluation";

      const recommendedScore = Number((ae.conditions_suggerees || {}).score_moyen_parcours_recommande || 70);
      const recommendedSteps = Number((ae.conditions_suggerees || {}).etapes_min_reussies || 1);

      const currentGlobal = globalScore();
      const currentDone = totalValidatedSteps();
      const enough = currentGlobal >= recommendedScore && currentDone >= recommendedSteps;
      const allowSkip = !!parcours?.regles?.autoriser_saut_autoevaluation;

      document.getElementById("ae-consigne").textContent = ae.consigne_prealable || "";

      const alertHost = document.getElementById("ae-alert");
      if (!allowSkip && !allStepsValidated()) {
        alertHost.innerHTML = '<div class="danger-box">L autoevaluation est disponible apres validation de toutes les etapes.</div>';
        btn.disabled = true;
      } else {
        btn.disabled = false;
        if (enough) {
          alertHost.innerHTML = '<div class="ok-box">Recommandation atteinte: vous etes pret pour l autoevaluation.</div>';
        } else {
          alertHost.innerHTML = '<div class="alert">Recommandation non atteinte (non bloquant): visez ' +
            `${recommendedScore}% de score moyen et ${recommendedSteps} etape(s) validee(s).` +
            '</div>';
        }
      }

      const last = state.autoEval.attempts[state.autoEval.attempts.length - 1] || null;
      const lastHost = document.getElementById("ae-last");
      if (!last) {
        lastHost.innerHTML = "";
        document.getElementById("btn-ae-restart").style.display = "none";
        document.getElementById("btn-ae-send").style.display = "none";
        document.getElementById("btn-ae-back").style.display = "none";
        return;
      }

      const ok = Number(last.score_pct || 0) >= recommendedScore;
      const message = ok
        ? (ae.feedback_fin?.si_reussite || "Autoevaluation reussie. Vous pouvez envoyer votre tentative.")
        : (ae.feedback_fin?.si_echec || "Autoevaluation en dessous du seuil recommande. Reprenez les etapes faibles et retentez.");

      const weak = computeWeakSteps();
      const weakTxt = weak.length
        ? "Etapes a renforcer: " + weak.map((w) => `${w.titre} (${w.score}%)`).join(", ")
        : "";

      lastHost.innerHTML = `
        <div class="${ok ? "ok-box" : "alert"}" style="margin-top:8px;">
          Derniere autoevaluation: ${Math.round(last.score_pct || 0)}% (${Math.round(last.points_obtenus || 0)}/${Math.round(last.points_total || 0)})
          <br>${esc(message)}
          ${weakTxt ? `<br><span class="small">${esc(weakTxt)}</span>` : ""}
        </div>
      `;

      document.getElementById("btn-ae-restart").style.display = parcours?.regles?.autoriser_recommencer_autoevaluation ? "inline-block" : "none";
      document.getElementById("btn-ae-send").style.display = parcours?.regles?.autoriser_envoyer_autoevaluation ? "inline-block" : "none";
      document.getElementById("btn-ae-back").style.display = "inline-block";
      document.getElementById("btn-ae-send").textContent = state.autoEval.sent ? "Autoevaluation envoyee" : "Envoyer l auto-evaluation";
      document.getElementById("btn-ae-send").disabled = state.autoEval.sent;
    }

    function allStepsValidated() {
      return (parcours.etapes || []).every((et) => !!state.steps[et.id]?.validated);
    }

    function renderAll() {
      renderHeader();
      renderStepsGrid();
      renderStepDetail();
      renderAutoEvalCard();
    }

    function addBlockAttempt(step, block, result) {
      const st = getStepState(step.id);
      if (!st || !st.blocks[block.id]) return;
      st.blocks[block.id].attempts.push(result);
      recomputeStepScore(step.id);
      saveState();
    }

    function selectNextUnlockedStep() {
      const idx = parcours.etapes.findIndex((_, i) => isStepUnlocked(i) && !state.steps[parcours.etapes[i].id]?.validated);
      if (idx >= 0) activeStepIndex = idx;
      else activeStepIndex = Math.max(0, parcours.etapes.length - 1);
    }

    function waitForParcoursResult(callbackKey, popup, timeoutMs = 60 * 60 * 1000) {
      return new Promise((resolve, reject) => {
        let done = false;
        const started = now();

        function finish(err, data) {
          if (done) return;
          done = true;
          window.removeEventListener("message", onMsg);
          window.removeEventListener("storage", onStorage);
          clearInterval(poll);
          if (err) reject(err);
          else resolve(data);
        }

        function parseValue(raw) {
          if (!raw) return null;
          try { return JSON.parse(raw); } catch { return null; }
        }

        function tryLocalStorage() {
          const raw = localStorage.getItem(callbackKey);
          const data = parseValue(raw);
          if (data && data.callbackKey === callbackKey) {
            localStorage.removeItem(callbackKey);
            finish(null, data.result || data);
            return true;
          }
          return false;
        }

        function onMsg(ev) {
          const d = ev.data;
          if (!d || d.type !== "PSE_PARCOURS_RESULT") return;
          if (d.callbackKey !== callbackKey) return;
          finish(null, d.result || d);
        }

        function onStorage(ev) {
          if (ev.key !== callbackKey) return;
          const data = parseValue(ev.newValue);
          if (!data) return;
          finish(null, data.result || data);
        }

        window.addEventListener("message", onMsg);
        window.addEventListener("storage", onStorage);

        const poll = setInterval(() => {
          if (tryLocalStorage()) return;
          if (popup && popup.closed) {
            if (now() - started > 3000) finish(new Error("Fenetre fermee sans resultat."));
            return;
          }
          if (now() - started > timeoutMs) {
            finish(new Error("Delai depasse sans retour de resultat."));
          }
        }, 500);

        tryLocalStorage();
      });
    }

    function computeBlockResult(exoRef, rawResult, attempt) {
      const scorePct = Number(rawResult?.score_pct || 0);
      const pointsTotal = Number(rawResult?.points_total || 100);
      const pointsObtenus = Number.isFinite(Number(rawResult?.points_obtenus))
        ? Number(rawResult.points_obtenus)
        : Math.round((scorePct / 100) * pointsTotal * 100) / 100;

      return {
        ref_exercice_id: exoRef,
        score_pct: Math.max(0, Math.min(100, Math.round(scorePct * 10) / 10)),
        points_obtenus: pointsObtenus,
        points_total: pointsTotal,
        tentative: attempt,
        timestamp: now(),
        details: rawResult?.details || {}
      };
    }

    async function runBlock(step, block, isRemediation) {
      const stepState = getStepState(step.id);
      if (!stepState) return;

      if (!block.ref_exercice_id) {
        showToast("Bloc sans ref_exercice_id.", true);
        return;
      }

      if (!isRemediation) {
        const maxAttempts = Number(parcours?.regles?.max_tentatives_par_exercice || 3);
        const attempts = stepState.blocks[block.id]?.attempts?.length || 0;
        if (attempts >= maxAttempts) {
          showToast("Nombre maximal de tentatives atteint pour ce bloc.", true);
          return;
        }
      }

      const callbackKey = `pse_parcours_block_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
      const base = new URL("exercices.html", window.location.href);
      base.searchParams.set("parcours", "1");
      base.searchParams.set("exoId", block.ref_exercice_id);
      base.searchParams.set("callbackKey", callbackKey);
      base.searchParams.set("sessionCode", sessionCode);
      base.searchParams.set("stepId", step.id);
      base.searchParams.set("blockId", block.id);

      let popup;
      try {
        popup = window.open(base.toString(), "_blank");
      } catch (_) {
        popup = null;
      }

      if (!popup) {
        showToast("Popup bloquee. Autorisez les fenetres puis recommencez.", true);
        return;
      }

      showToast("Exercice lance. Resultat en attente...");

      try {
        const raw = await waitForParcoursResult(callbackKey, popup);
        const attemptNum = isRemediation ? 1 : ((stepState.blocks[block.id]?.attempts?.length || 0) + 1);
        const normalized = computeBlockResult(block.ref_exercice_id, raw, attemptNum);

        if (!isRemediation) {
          addBlockAttempt(step, block, normalized);
        }

        if (!isRemediation) {
          if (getStepState(step.id)?.validated) {
            showToast("Etape validee.");
            selectNextUnlockedStep();
          } else {
            showToast("Resultat enregistre. Seuil etape non atteint.");
          }
        } else {
          showToast("Remediation terminee.");
        }

        renderAll();
      } catch (e) {
        showToast("Aucun resultat recu: " + e.message, true);
      }
    }

    function normalizeAutoEvalResult(raw) {
      const scorePct = Number(raw?.score_pct || 0);
      const pointsTotal = Number(raw?.points_total || 20);
      const pointsObtenus = Number.isFinite(Number(raw?.points_obtenus))
        ? Number(raw.points_obtenus)
        : Math.round((scorePct / 100) * pointsTotal * 100) / 100;
      return {
        ref_autoeval_id: (parcours?.autoevaluation?.ref_autoeval_id || ""),
        score_pct: Math.max(0, Math.min(100, Math.round(scorePct * 10) / 10)),
        points_obtenus: pointsObtenus,
        points_total: pointsTotal,
        tentative: (state.autoEval.attempts.length + 1),
        timestamp: now(),
        details: raw?.details || {}
      };
    }

    async function launchAutoEval() {
      const refId = (parcours.autoevaluation || {}).ref_autoeval_id;
      if (!refId) {
        showToast("Aucune autoevaluation liee a ce parcours.", true);
        return;
      }

      const callbackKey = `pse_parcours_ae_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
      const base = new URL("eleve_eval.html", window.location.href);
      base.searchParams.set("parcours", "1");
      base.searchParams.set("evalId", refId);
      base.searchParams.set("code", sessionCode);
      base.searchParams.set("classe", "PARCOURS");
      base.searchParams.set("callbackKey", callbackKey);

      let popup;
      try {
        popup = window.open(base.toString(), "_blank");
      } catch (_) {
        popup = null;
      }

      if (!popup) {
        showToast("Popup bloquee. Autorisez les fenetres puis recommencez.", true);
        return;
      }

      showToast("Autoevaluation lancee...");

      try {
        const raw = await waitForParcoursResult(callbackKey, popup);
        const res = normalizeAutoEvalResult(raw);
        state.autoEval.attempts.push(res);
        saveState();
        renderAutoEvalCard();
        showToast("Autoevaluation terminee.");
      } catch (e) {
        showToast("Retour autoevaluation manquant: " + e.message, true);
      }
    }

    function sendAutoEvalFlag() {
      if (!parcours?.regles?.autoriser_envoyer_autoevaluation) return;
      state.autoEval.sent = true;
      saveState();
      renderAutoEvalCard();
      showToast("Tentative marquee comme envoyee.");
    }

    function resetLocalSession() {
      const ok = window.confirm("Reinitialiser la progression locale de ce parcours pour ce code ?");
      if (!ok) return;
      localStorage.removeItem(storageKey());
      loadState();
      chooseActiveStep();
      renderAll();
      showToast("Progression locale reinitialisee.");
    }

    function bindUIEvents() {
      document.getElementById("steps-grid").addEventListener("click", (e) => {
        const card = e.target.closest(".step[data-step-index]");
        if (!card) return;
        const idx = Number(card.getAttribute("data-step-index"));
        if (!isStepUnlocked(idx)) return;
        activeStepIndex = idx;
        renderAll();
      });

      // Delegated click handler for step-detail (avoids listener stacking on re-render)
      document.getElementById("step-detail").addEventListener("click", async (e) => {
        const runBtn = e.target.closest("[data-run-block]");
        if (runBtn) {
          const blockId = runBtn.getAttribute("data-run-block");
          const et = (parcours.etapes || [])[activeStepIndex];
          if (!et) return;
          const block = (et.blocs || []).find((b) => b.id === blockId);
          if (block) await runBlock(et, block, false);
          return;
        }
        const remBtn = e.target.closest("[data-run-rem]");
        if (remBtn) {
          const idx = Number(remBtn.getAttribute("data-run-rem"));
          const et = (parcours.etapes || [])[activeStepIndex];
          if (!et) return;
          const rem = ((et.remediation || {}).si_echec || [])[idx];
          if (!rem) return;
          const fakeBlock = {
            id: "REM_" + (idx + 1),
            label: rem.message || "Remediation",
            ref_exercice_id: rem.ref_exercice_id,
            poids: 1
          };
          await runBlock(et, fakeBlock, true);
          return;
        }
        if (e.target.id === "btn-next-step" || e.target.closest("#btn-next-step")) {
          const et = (parcours.etapes || [])[activeStepIndex];
          const st = et ? getStepState(et.id) : null;
          if (!st?.validated) return;
          if (activeStepIndex < (parcours.etapes || []).length - 1) {
            activeStepIndex += 1;
            renderAll();
          } else {
            showToast("Parcours termine. Vous pouvez lancer ou relancer l autoevaluation.");
          }
        }
      });

      document.getElementById("btn-autoeval").addEventListener("click", launchAutoEval);
      document.getElementById("btn-ae-restart").addEventListener("click", launchAutoEval);
      document.getElementById("btn-ae-send").addEventListener("click", sendAutoEvalFlag);
      document.getElementById("btn-ae-back").addEventListener("click", () => {
        chooseActiveStep();
        renderAll();
      });
      document.getElementById("btn-reset-session").addEventListener("click", resetLocalSession);
    }

    async function runBridgeBlock(blockConfig) {
      const refId = (blockConfig && blockConfig.ref_exercice_id) ? String(blockConfig.ref_exercice_id).trim() : "";
      if (!refId) throw new Error("ref_exercice_id manquant");

      const callbackKey = `pse_parcours_bridge_block_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`;
      const base = new URL("exercices.html", window.location.href);
      base.searchParams.set("parcours", "1");
      base.searchParams.set("exoId", refId);
      base.searchParams.set("callbackKey", callbackKey);
      base.searchParams.set("sessionCode", sessionCode);

      const popup = window.open(base.toString(), "_blank");
      if (!popup) throw new Error("Popup bloquee");

      const raw = await waitForParcoursResult(callbackKey, popup);
      return computeBlockResult(refId, raw, Number(blockConfig?.tentative || 1));
    }

    // Bridge API for optional direct integrations
    window.PSE_PARCOURS_BRIDGE = {
      startBlock: async function(blockConfig) {
        const result = await runBridgeBlock(blockConfig || {});
        return window.PSE_PARCOURS_BRIDGE.onBlockCompleted(result);
      },
      onBlockCompleted: function(result) {
        return result;
      },
      startAutoEval: async function(refId) {
        if (refId && parcours?.autoevaluation) parcours.autoevaluation.ref_autoeval_id = refId;
        await launchAutoEval();
        const last = state.autoEval.attempts[state.autoEval.attempts.length - 1] || null;
        return window.PSE_PARCOURS_BRIDGE.onAutoEvalCompleted(last);
      },
      onAutoEvalCompleted: function(result) {
        return result;
      }
    };

    async function loadParcours() {
      if (!parcoursId) {
        document.getElementById("head-loader").textContent = "Parametre manquant: ?id=...";
        document.getElementById("head-loader").className = "err";
        return;
      }

      const snap = await getDoc(doc(db, "parcours_banque", parcoursId));
      if (!snap.exists()) {
        document.getElementById("head-loader").textContent = "Parcours introuvable.";
        document.getElementById("head-loader").className = "err";
        return;
      }

      parcours = ensureParcoursShape(snap.data());
      loadState();
      chooseActiveStep();
      renderAll();
      bindUIEvents();
    }

    loadParcours().catch((e) => {
      console.error(e);
      document.getElementById("head-loader").textContent = "Erreur de chargement: " + e.message;
      document.getElementById("head-loader").className = "err";
    });
  </script>
</body>
</html>

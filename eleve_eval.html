<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Evaluation PSE</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f0f4f8; min-height: 100vh; color: #1e293b;
        }

        /* === SCREENS === */
        .screen {
            position: fixed; inset: 0; z-index: 10;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; padding: 20px;
            overflow-y: auto; background: #0f172a;
        }
        .screen-hidden { display: none !important; }

        /* === LOGIN === */
        .login-card {
            background: white; border-radius: 20px; padding: 40px; text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.08); max-width: 420px; width: 100%;
        }
        .login-icon { font-size: 4rem; margin-bottom: 16px; }
        .login-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 8px; }
        .login-sub { color: #64748b; margin-bottom: 24px; font-size: 0.95rem; }
        .login-input {
            width: 100%; padding: 16px; border: 2px solid #e2e8f0; border-radius: 12px;
            font-size: 1.3rem; text-align: center; letter-spacing: 4px; font-weight: 800;
            text-transform: uppercase; outline: none; margin-bottom: 16px;
        }
        .login-input:focus { border-color: #3b82f6; box-shadow: 0 0 0 3px rgba(59,130,246,0.1); }
        .login-btn {
            width: 100%; padding: 16px; background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white; border: none; border-radius: 12px; font-size: 1.1rem;
            font-weight: 700; cursor: pointer; transition: 0.2s;
        }
        .login-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(59,130,246,0.4); }
        .login-error {
            background: #fef2f2; color: #dc2626; padding: 10px; border-radius: 8px;
            margin-top: 12px; display: none; font-size: 0.9rem; border-left: 4px solid #dc2626;
        }
        .login-error.visible { display: block; }

        /* === EVAL LIST === */
        .eval-list-screen { background: #f0f4f8; }
        .student-banner {
            background: linear-gradient(135deg, #3b82f6, #2563eb); color: white;
            padding: 16px 24px; border-radius: 16px; margin-bottom: 24px;
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; max-width: 700px;
        }
        .student-banner .sb-info { font-weight: 700; font-size: 1.1rem; }
        .student-banner .sb-class { opacity: 0.8; font-size: 0.9rem; }
        .student-banner .sb-logout {
            background: rgba(255,255,255,0.2); border: none; color: white;
            padding: 8px 16px; border-radius: 8px; cursor: pointer; font-weight: 600;
        }

        .eval-list-title { font-size: 1.3rem; font-weight: 800; margin-bottom: 16px; text-align: center; }
        .eval-list-container { width: 100%; max-width: 700px; }
        .eval-list-empty { text-align: center; color: #94a3b8; padding: 40px; }

        .eval-card {
            background: white; border-radius: 16px; padding: 20px; margin-bottom: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); cursor: pointer; transition: 0.2s;
            border: 2px solid transparent;
        }
        .eval-card:hover { border-color: #3b82f6; transform: translateY(-2px); }
        .eval-card.done { opacity: 0.5; cursor: not-allowed; }
        .eval-card-title { font-weight: 700; font-size: 1.1rem; margin-bottom: 6px; }
        .eval-card-meta { display: flex; gap: 8px; flex-wrap: wrap; }
        .eval-card-meta span {
            font-size: 0.75rem; padding: 3px 10px; border-radius: 20px; font-weight: 600;
        }
        .ecm-questions { background: #dbeafe; color: #1e40af; }
        .ecm-bareme { background: #ede9fe; color: #5b21b6; }
        .ecm-timer { background: #fef3c7; color: #92400e; }
        .ecm-done { background: #dcfce7; color: #166534; }
        .ecm-classe { background: #fef3c7; color: #92400e; font-weight: 600; }
        .ecm-classe.ecm-all { background: #e2e8f0; color: #64748b; }
        .ecm-module { background: #f0fdf4; color: #166534; }
        .ecm-pastille { display: inline-flex; align-items: center; gap: 6px; }
        .ecm-pastille-dot { width: 9px; height: 9px; border-radius: 999px; display: inline-block; }
        .ecm-pastille-facile { background: #dcfce7; color: #166534; }
        .ecm-pastille-facile .ecm-pastille-dot { background: #22c55e; }
        .ecm-pastille-moyen { background: #dbeafe; color: #1e40af; }
        .ecm-pastille-moyen .ecm-pastille-dot { background: #3b82f6; }
        .ecm-pastille-eleve { background: #fee2e2; color: #991b1b; }
        .ecm-pastille-eleve .ecm-pastille-dot { background: #ef4444; }

        /* === EVALUATION === */
        .eval-screen { background: #f0f4f8; padding: 0; }

        .eval-topbar {
            background: white; border-bottom: 1px solid #e2e8f0; padding: 12px 20px;
            display: flex; justify-content: space-between; align-items: center;
            position: sticky; top: 0; z-index: 50; width: 100%;
        }
        .eval-topbar .et-title { font-weight: 700; font-size: 0.95rem; }
        .eval-topbar .et-timer { font-weight: 800; font-size: 1.1rem; color: #3b82f6; }
        .eval-topbar .et-progress { font-size: 0.85rem; color: #64748b; }

        .eval-nav {
            display: flex; gap: 8px; padding: 12px 20px; flex-wrap: wrap;
            justify-content: center; background: white; border-bottom: 1px solid #e2e8f0;
        }
        .nav-group {
            display: flex; flex-direction: column; align-items: center; gap: 2px;
            padding: 4px 6px; border-radius: 10px;
        }
        .nav-group-doc {
            background: rgba(0,0,0,0.02); border-bottom: 3px solid var(--doc-color, #fbbf24);
        }
        .nav-group-label {
            font-size: 0.6rem; font-weight: 700; white-space: nowrap;
            overflow: hidden; text-overflow: ellipsis; max-width: 120px; text-align: center;
            color: var(--doc-color, #92400e);
        }
        .nav-group-btns { display: flex; gap: 4px; }
        .nav-btn {
            width: 38px; height: 38px; border-radius: 10px; border: 2px solid #e2e8f0;
            background: white; font-weight: 700; font-size: 0.85rem; cursor: pointer;
            transition: 0.2s; color: #64748b;
        }
        .nav-btn.active { border-color: #3b82f6; background: #3b82f6; color: white; }
        .nav-btn.answered { border-color: #22c55e; background: #dcfce7; color: #166534; }
        .nav-btn.answered.active { background: #22c55e; color: white; }

        .eval-body {
            flex: 1; padding: 20px; overflow-y: auto; display: flex;
            flex-direction: column; align-items: center; width: 100%;
        }

        .question-container {
            background: white; border-radius: 20px; padding: 30px; max-width: 700px;
            width: 100%; box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        /* Document display (persistent container) */
        #doc-container {
            max-width: 700px; width: 100%; display: none;
        }
        #doc-container .doc-display {
            background: #fffbeb; border: 2px solid #fbbf24; border-radius: 20px 20px 0 0;
            padding: 16px; margin-bottom: 0; border-bottom: none;
            max-height: 40vh; overflow-y: auto;
        }
        #doc-container .doc-display h4 { color: #92400e; margin-bottom: 8px; font-size: 0.9rem; }
        #doc-container .doc-display img { max-width: 100%; max-height: 35vh; object-fit: contain; border-radius: 8px; margin-top: 8px; }
        #doc-container .doc-display .doc-text { color: #78350f; line-height: 1.6; white-space: pre-wrap; font-size: 0.95rem; }
        #doc-container .doc-display iframe { width: 100%; aspect-ratio: 16/9; max-height: 35vh; border: none; border-radius: 8px; margin-top: 8px; }
        .question-container.has-doc {
            border-top-left-radius: 0; border-top-right-radius: 0;
            border-top: 1px solid #fde68a;
        }

        /* Section badge */
        .q-section-badge {
            font-size: 0.75rem; color: #64748b; font-weight: 600;
            padding: 6px 12px; border-left: 3px solid #fbbf24;
            background: #fefce8; border-radius: 0 8px 8px 0; margin-bottom: 12px;
        }

        .q-number { color: #3b82f6; font-weight: 800; font-size: 0.9rem; margin-bottom: 6px; }
        .q-comp-badge { font-size: 0.75rem; background: #dbeafe; color: #1e40af; padding: 2px 8px; border-radius: 20px; margin-left: 8px; }
        .q-text { font-size: 1.15rem; font-weight: 600; line-height: 1.5; margin-bottom: 20px; }
        .q-multi-hint { font-size: 0.8rem; color: #64748b; font-style: italic; margin-bottom: 12px; }

        /* Answer options */
        .answer-option {
            display: flex; align-items: center; gap: 12px; padding: 14px 18px;
            border: 2px solid #e2e8f0; border-radius: 12px; margin-bottom: 8px;
            cursor: pointer; transition: 0.2s; font-weight: 500;
        }
        .answer-option:hover { border-color: #3b82f6; background: #f0f7ff; }
        .answer-option.selected { border-color: #3b82f6; background: #dbeafe; }
        .answer-option input { accent-color: #3b82f6; width: 20px; height: 20px; cursor: pointer; }

        .vf-options { display: flex; gap: 12px; }
        .vf-option {
            flex: 1; padding: 20px; border: 2px solid #e2e8f0; border-radius: 16px;
            text-align: center; font-weight: 700; font-size: 1.2rem; cursor: pointer;
            transition: 0.2s;
        }
        .vf-option:hover { border-color: #3b82f6; }
        .vf-option.selected-true { border-color: #22c55e; background: #dcfce7; color: #166534; }
        .vf-option.selected-false { border-color: #ef4444; background: #fef2f2; color: #dc2626; }

        .text-answer {
            width: 100%; padding: 14px; border: 2px solid #e2e8f0; border-radius: 12px;
            font-size: 1.1rem; outline: none; font-family: inherit;
        }
        .text-answer:focus { border-color: #3b82f6; }
        .number-answer { width: 200px; text-align: center; }

        /* Navigation buttons */
        .eval-footer {
            padding: 16px 20px; background: white; border-top: 1px solid #e2e8f0;
            display: flex; justify-content: space-between; align-items: center; width: 100%;
        }
        .ef-btn {
            padding: 12px 24px; border-radius: 12px; font-weight: 700; cursor: pointer;
            border: none; font-size: 0.95rem; transition: 0.2s;
        }
        .ef-prev { background: #e2e8f0; color: #475569; }
        .ef-next { background: #3b82f6; color: white; }
        .ef-submit { background: #22c55e; color: white; font-size: 1rem; }
        .ef-btn:hover { opacity: 0.85; transform: translateY(-1px); }
        .ef-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none; }

        /* === RESULTS === */
        .results-screen { background: #f0f4f8; padding: 20px; }
        .results-container { max-width: 700px; width: 100%; }

        .score-card {
            background: white; border-radius: 20px; padding: 40px; text-align: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08); margin-bottom: 24px;
        }
        .score-big { font-size: 4rem; font-weight: 900; margin-bottom: 8px; }
        .score-ok { color: #22c55e; }
        .score-mid { color: #f59e0b; }
        .score-low { color: #ef4444; }
        .score-label { font-size: 1.2rem; color: #64748b; font-weight: 600; }

        .comps-card {
            background: white; border-radius: 16px; padding: 20px; margin-bottom: 16px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        .comps-card h3 { font-size: 1rem; margin-bottom: 12px; }
        .comp-row {
            display: flex; justify-content: space-between; align-items: center;
            padding: 10px 0; border-bottom: 1px solid #f1f5f9;
        }
        .comp-row:last-child { border-bottom: none; }
        .comp-name { font-weight: 600; font-size: 0.9rem; }
        .comp-badge {
            padding: 4px 12px; border-radius: 20px; font-weight: 700; font-size: 0.8rem;
        }
        .cb-M { background: #dcfce7; color: #166534; }
        .cb-A { background: #dbeafe; color: #1e40af; }
        .cb-I { background: #fef3c7; color: #92400e; }
        .cb-NT { background: #e2e8f0; color: #64748b; }

        .detail-card {
            background: white; border-radius: 16px; padding: 20px; margin-bottom: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05); border-left: 4px solid #e2e8f0;
        }
        .detail-card.correct { border-left-color: #22c55e; }
        .detail-card.incorrect { border-left-color: #ef4444; }
        .detail-card.unanswered { border-left-color: #94a3b8; }

        .dc-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; }
        .dc-num { font-weight: 800; color: #3b82f6; font-size: 0.9rem; }
        .dc-result { font-weight: 700; font-size: 0.85rem; }
        .dc-correct { color: #22c55e; }
        .dc-incorrect { color: #ef4444; }
        .dc-question { font-weight: 600; margin-bottom: 10px; line-height: 1.4; }

        .dc-answer-block {
            padding: 10px 14px; border-radius: 8px; margin-bottom: 6px; font-size: 0.9rem;
        }
        .dc-your { background: #f0f9ff; border-left: 3px solid #3b82f6; }
        .dc-good { background: #f0fdf4; border-left: 3px solid #22c55e; }
        .dc-correction { background: #fffbeb; border-left: 3px solid #f59e0b; }
        .dc-explication { background: #faf5ff; border-left: 3px solid #8b5cf6; }
        .dc-label { font-weight: 700; font-size: 0.8rem; margin-bottom: 4px; }

        .mapse-link {
            text-align: center; padding: 20px; color: #64748b; font-size: 0.9rem;
        }
        .mapse-link a { color: #3b82f6; font-weight: 700; text-decoration: none; }

        /* === WARNING SCREEN (pre-exam) === */
        .warning-box {
            background: white; border-radius: 20px; padding: 40px; max-width: 560px; width: 100%;
            box-shadow: 0 8px 30px rgba(0,0,0,0.1); text-align: center;
        }
        .warning-box .warn-icon { font-size: 4rem; margin-bottom: 12px; }
        .warning-box h2 { font-size: 1.4rem; font-weight: 800; margin-bottom: 20px; color: #1e293b; }
        .warning-box ul {
            text-align: left; margin: 0 auto 20px; max-width: 420px;
            list-style: none; padding: 0;
        }
        .warning-box ul li {
            padding: 10px 14px; margin-bottom: 8px; border-radius: 10px;
            background: #fef3c7; border-left: 4px solid #f59e0b;
            font-size: 0.95rem; font-weight: 500; color: #78350f;
        }
        .warning-box ul li::before { content: '‚ö†Ô∏è '; }
        .warning-box .warn-note {
            font-size: 0.9rem; color: #64748b; margin-bottom: 24px; line-height: 1.5;
        }
        .warning-box .warn-btn {
            padding: 16px 40px; background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white; border: none; border-radius: 14px; font-size: 1.1rem;
            font-weight: 800; cursor: pointer; transition: 0.2s;
        }
        .warning-box .warn-btn:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(34,197,94,0.4); }
        .warning-box .warn-btn:disabled { opacity: 0.45; cursor: not-allowed; transform: none; box-shadow: none; }
        .warn-pastille {
            margin: 0 auto 16px; max-width: 420px; text-align: left;
            padding: 12px 14px; border-radius: 10px; background: #eff6ff; border-left: 4px solid #3b82f6;
        }
        .warn-pastille-title { font-size: 0.88rem; font-weight: 700; margin-bottom: 6px; color: #1e3a8a; }
        .warn-pastille .warn-pastille-chip { display: inline-flex; align-items: center; gap: 6px; font-size: 0.78rem; font-weight: 700; padding: 4px 10px; border-radius: 999px; margin-bottom: 8px; }
        .warn-pastille-check { font-size: 0.82rem; color: #334155; display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .warn-pastille-check input { accent-color: #3b82f6; width: 17px; height: 17px; }

        /* === CHRONO WARNING SCREEN === */
        .chrono-box {
            background: white; border-radius: 20px; padding: 40px; max-width: 580px; width: 100%;
            box-shadow: 0 8px 30px rgba(0,0,0,0.1); text-align: center;
        }
        .chrono-box .chrono-icon { font-size: 4rem; margin-bottom: 12px; }
        .chrono-box h2 { font-size: 1.4rem; font-weight: 800; margin-bottom: 16px; color: #1e293b; }
        .chrono-box .chrono-duree {
            display: inline-block; padding: 12px 28px; border-radius: 12px;
            background: linear-gradient(135deg, #f59e0b, #d97706); color: white;
            font-size: 1.5rem; font-weight: 900; margin-bottom: 20px;
        }
        .chrono-box ul {
            text-align: left; margin: 0 auto 20px; max-width: 460px;
            list-style: none; padding: 0;
        }
        .chrono-box ul li {
            padding: 10px 14px; margin-bottom: 8px; border-radius: 10px;
            background: #fff7ed; border-left: 4px solid #f59e0b;
            font-size: 0.95rem; color: #92400e;
        }
        .chrono-box ul li::before { content: '‚è±Ô∏è '; }
        .chrono-box .chrono-engage {
            font-size: 0.88rem; color: #64748b; margin-bottom: 24px; line-height: 1.5;
            font-style: italic;
        }
        .chrono-box .chrono-btn-group { display: flex; gap: 12px; justify-content: center; flex-wrap: wrap; }
        .chrono-box .chrono-btn-go {
            padding: 16px 32px; background: linear-gradient(135deg, #22c55e, #16a34a);
            color: white; border: none; border-radius: 14px; font-size: 1.05rem;
            font-weight: 800; cursor: pointer; transition: 0.2s;
        }
        .chrono-box .chrono-btn-go:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(34,197,94,0.4); }
        .chrono-box .chrono-btn-cancel {
            padding: 16px 32px; background: #e2e8f0;
            color: #475569; border: none; border-radius: 14px; font-size: 1.05rem;
            font-weight: 700; cursor: pointer; transition: 0.2s;
        }
        .chrono-box .chrono-btn-cancel:hover { background: #cbd5e1; }

        /* === ANTI-CHEAT ALERT === */
        #alert-tabswitch {
            position: fixed; inset: 0; z-index: 9999; background: rgba(220,38,38,0.95);
            display: none; align-items: center; justify-content: center;
            flex-direction: column; color: white; text-align: center;
            animation: flashBg 0.4s ease 3;
        }
        @keyframes flashBg { 0%,100% { opacity: 1; } 50% { opacity: 0.7; } }
        #alert-tabswitch .alert-icon { font-size: 4rem; margin-bottom: 16px; }
        #alert-tabswitch .alert-text { font-size: 1.5rem; font-weight: 800; margin-bottom: 8px; }
        #alert-tabswitch .alert-sub { font-size: 1rem; opacity: 0.8; }

        /* Barre de progression mobile (cachee par defaut sur desktop) */
        .eval-progress-bar { display: none; width: 100%; height: 4px; background: #e2e8f0; }
        .eval-progress-fill { height: 100%; width: 0%; background: #22c55e; transition: width 0.3s ease; border-radius: 0 2px 2px 0; }
        /* Bouton toggle document (cache sur desktop) */
        .doc-toggle-btn { display: none; width: 100%; padding: 10px 14px; background: #fffbeb; border: 2px solid #fbbf24; border-radius: 12px; font-weight: 600; font-size: 0.85rem; color: #92400e; cursor: pointer; text-align: left; margin-bottom: 0; }

        @media (max-width: 600px) {
            /* Fix: screens ne doivent pas centrer verticalement sur mobile */
            .screen { justify-content: flex-start; }
            .login-card { padding: 24px; margin-top: 40px; }
            .eval-body { padding: 10px; }
            .question-container { padding: 16px; }
            .q-text { font-size: 1rem; }
            .score-big { font-size: 3rem; }
            #doc-container .doc-display img { max-height: 60vh; }
            /* Topbar plus compact */
            .eval-topbar { padding: 8px 12px; }
            .eval-topbar .et-title { font-size: 0.8rem; max-width: 40%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
            .eval-topbar .et-timer { font-size: 0.95rem; }
            /* Nav numerotee cachee sur mobile ‚Äî remplacee par barre de progression */
            .eval-nav { display: none; }
            .eval-progress-bar { display: block; }
            /* Document en flux continu sur mobile (scroll naturel) */
            .doc-toggle-btn { display: none; }
            #doc-container .doc-display { max-height: none; padding: 10px; font-size: 0.85rem; overflow-y: visible; transition: none; }
            #doc-container .doc-display.doc-collapsed { max-height: none; overflow: visible; padding-top: 10px; padding-bottom: 10px; border-width: 2px; }
            /* Bouton flottant document/questions */
            .mobile-scroll-fab { position: fixed; bottom: 70px; right: 12px; z-index: 40; background: #3b82f6; color: white; border: none; border-radius: 50%; width: 48px; height: 48px; font-size: 1.3rem; box-shadow: 0 2px 10px rgba(0,0,0,0.25); display: none; cursor: pointer; -webkit-tap-highlight-color: transparent; }
            .mobile-scroll-fab.fab-visible { display: -webkit-flex; display: flex; -webkit-align-items: center; align-items: center; -webkit-justify-content: center; justify-content: center; }
            #doc-container .doc-display h4 { font-size: 0.8rem; }
            /* Footer boutons compacts */
            .eval-footer { padding: 10px 12px; }
            .ef-btn { padding: 10px 16px; font-size: 0.85rem; }
            /* Warning/chrono screens compacts */
            .warning-box, .chrono-box { padding: 24px; }
            .warning-box h2, .chrono-box h2 { font-size: 1.1rem; }
            .warning-box ul li, .chrono-box ul li { font-size: 0.85rem; padding: 8px 10px; }
            .chrono-box .chrono-duree { font-size: 1.2rem; padding: 10px 20px; }
            .chrono-box .chrono-btn-go, .chrono-box .chrono-btn-cancel { padding: 12px 20px; font-size: 0.95rem; }
            /* Ordonner sur mobile */
            .ord-item { padding: 10px 12px; gap: 8px; }
            .ord-text { font-size: 0.9rem; }
            .ord-select select { min-height: 44px; font-size: 1.1rem; }
            /* Resultats sur mobile */
            .detail-card { padding: 14px; }
            .dc-header { flex-direction: column; align-items: flex-start; gap: 4px; }
            .dc-question { font-size: 0.9rem; }
            .dc-answer-block { padding: 8px 10px; font-size: 0.85rem; }
            .student-banner { padding: 12px 16px; border-radius: 12px; flex-direction: column; gap: 8px; text-align: center; }
        }
        /* Ordonner ‚Äî theme clair coherent avec la page */
        .ord-list { display: flex; flex-direction: column; gap: 8px; }
        .ord-item { background: white; padding: 12px 16px; border-radius: 10px; border: 2px solid #e2e8f0; display: flex; align-items: center; gap: 12px; transition: border-color 0.2s; }
        .ord-item:hover { border-color: #3b82f6; }
        .ord-text { flex: 1; color: #1e293b; font-weight: 500; }
        .ord-select { flex-shrink: 0; }
        .ord-select select { padding: 10px 14px; border-radius: 8px; border: 2px solid #3b82f6; background: white; color: #1e293b; font-weight: 700; font-size: 1rem; min-width: 52px; min-height: 44px; cursor: pointer; }
        .ord-select select:focus { border-color: #60a5fa; outline: none; box-shadow: 0 0 0 3px rgba(59,130,246,0.15); }
        .ord-reset-btn { margin-top: 8px; padding: 8px 14px; font-size: 0.8rem; border-radius: 6px; border: 1px solid #cbd5e1; background: white; color: #64748b; cursor: pointer; }
        .ord-reset-btn:hover { color: #1e293b; border-color: #94a3b8; background: #f8fafc; }
        /* Document image placeholder */
        .doc-img-placeholder { padding: 20px; text-align: center; color: #94a3b8; background: #f1f5f9; border-radius: 8px; margin-top: 8px; }
    </style>
</head>
<body>

<!-- ANTI-CHEAT ALERT -->
<div id="alert-tabswitch">
    <div class="alert-icon">‚ö†Ô∏è</div>
    <div class="alert-text">Sortie detectee !</div>
    <div class="alert-sub" id="alert-count-msg">Ne quittez pas cette page pendant l'evaluation.</div>
</div>

<!-- SCREEN 1: LOGIN -->
<div class="screen" id="screen-login">
    <div class="login-card">
        <div class="login-icon">üìã</div>
        <div class="login-title">Auto-Evaluation PSE</div>
        <div class="login-sub">Entre ton code eleve pour acceder a tes evaluations.</div>
        <input type="text" class="login-input" id="login-code" maxlength="10" placeholder="CODE" autocomplete="off">
        <button class="login-btn" id="btn-login" onclick="doLogin()">Se connecter</button>
        <div class="login-error" id="login-error"></div>
    </div>
</div>

<!-- SCREEN 2: EVAL LIST -->
<div class="screen eval-list-screen screen-hidden" id="screen-list">
    <div class="student-banner" id="student-banner">
        <div>
            <div class="sb-info" id="sb-info"></div>
            <div class="sb-class" id="sb-class"></div>
        </div>
        <button class="sb-logout" onclick="doLogout()">Deconnexion</button>
    </div>
    <div class="eval-list-container">
        <div class="eval-list-title">Mes evaluations disponibles</div>
        <div id="eval-list-content"></div>
    </div>
</div>

<!-- SCREEN 2b: WARNING PRE-EXAM -->
<div class="screen screen-hidden" id="screen-warning">
    <div class="warning-box">
        <div class="warn-icon">üõ°Ô∏è</div>
        <h2>Evaluation surveillee</h2>
        <ul>
            <li>Les sorties d'onglet sont detectees et comptabilisees</li>
            <li>Le copier-coller est bloque et comptabilise</li>
            <li>Le clic droit est desactive</li>
            <li>Les captures d'ecran sont detectees et interdites</li>
            <li>Votre enseignant verra toutes les alertes dans ses resultats</li>
        </ul>
        <div class="warn-pastille" id="warn-pastille-block" style="display:none;">
            <div class="warn-pastille-title">Controle de la pastille enseignant</div>
            <div id="warn-pastille-chip"></div>
            <label class="warn-pastille-check">
                <input type="checkbox" id="warn-pastille-check" onchange="updateWarningStartButton()">
                <span>J'ai verifie avec mon professeur que je lance la bonne pastille.</span>
            </label>
        </div>
        <p class="warn-note">En cliquant sur "Commencer", vous acceptez ces conditions de surveillance.<br>Bonne evaluation !</p>
        <button class="warn-btn" id="warn-start-btn" onclick="proceedAfterWarning()">Commencer l'evaluation</button>
    </div>
</div>

<!-- SCREEN 2c: CHRONO WARNING -->
<div class="screen screen-hidden" id="screen-chrono-warning">
    <div class="chrono-box">
        <div class="chrono-icon">‚è±Ô∏è</div>
        <h2>Evaluation chronometree</h2>
        <div class="chrono-duree" id="chrono-warn-duree">-- minutes</div>
        <ul>
            <li>Le chronometre demarre des que vous cliquez sur <strong>"Je suis pret"</strong></li>
            <li>Vous devez rester concentre pendant toute la duree (<span class="chrono-warn-minutes">--</span> minutes sans interruption)</li>
            <li>A la fin du temps, votre copie sera <strong>envoyee automatiquement</strong>, meme si vous n'avez pas termine</li>
            <li>Assurez-vous d'etre dans un endroit calme, sans distraction, pret a travailler</li>
        </ul>
        <p class="chrono-engage">En cliquant sur "Je suis pret", vous confirmez etre disponible et concentre pour les <span class="chrono-warn-minutes">--</span> prochaines minutes.</p>
        <div class="chrono-btn-group">
            <button class="chrono-btn-go" onclick="confirmStartEval()">‚úÖ Je suis pret, lancer l'evaluation</button>
            <button class="chrono-btn-cancel" onclick="cancelChronoStart()">‚Üê Pas maintenant</button>
        </div>
    </div>
</div>

<!-- SCREEN 3: EVALUATION -->
<div class="screen eval-screen screen-hidden" id="screen-eval" style="justify-content:flex-start; padding:0;">
    <div class="eval-topbar">
        <div class="et-title" id="et-title"></div>
        <div class="et-timer" id="et-timer"></div>
        <div class="et-progress" id="et-progress"></div>
    </div>
    <div class="eval-progress-bar" id="eval-progress-bar"><div class="eval-progress-fill" id="eval-progress-fill"></div></div>
    <div class="eval-nav" id="eval-nav"></div>
    <div class="eval-body">
        <div id="doc-container"></div>
        <div class="question-container" id="question-container"></div>
    </div>
    <div class="eval-footer">
        <button class="ef-btn ef-prev" id="btn-prev" onclick="prevQ()">‚óÄ Precedente</button>
        <button class="ef-btn ef-submit" id="btn-submit" onclick="submitEval()" style="display:none;">Soumettre ‚úì</button>
        <button class="ef-btn ef-next" id="btn-next" onclick="nextQ()">Suivante ‚ñ∂</button>
    </div>
</div>

<!-- SCREEN 4: RESULTS -->
<div class="screen results-screen screen-hidden" id="screen-results" style="justify-content:flex-start; padding-top:30px;">
    <div class="results-container" id="results-container"></div>
</div>

<script src="data_eleves.js"></script>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
    import { getFirestore, doc, setDoc, getDoc, getDocs, collection, query, where, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

    const firebaseConfig = {
        apiKey: "AIzaSyAWdCMvOiAJln3eT9LIAQD3RWJUD0lQcLI",
        authDomain: "devoirs-pse.firebaseapp.com",
        projectId: "devoirs-pse",
        storageBucket: "devoirs-pse.firebasestorage.app",
        messagingSenderId: "614730413904",
        appId: "1:614730413904:web:a5dd478af5de30f6bede55"
    };
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // === GROUPES DE CLASSES (copie minimale de data_modules.js) ===
    const GROUPES_CLASSES = {
        "B2GATL": ["B2GATL1", "B2GATL2"],
        "B1AGO": ["B1AGO1", "B1AGO2"],
        "BTAGO": ["BTAGO1", "BTAGO2"]
    };
    function getClassesFromGroupe(id) {
        return GROUPES_CLASSES[id] || [id];
    }

    // === STATE ===
    let currentUser = null; // { userCode, classe }
    let currentEval = null; // eval data from eval_banque
    let currentEvalId = null;
    let currentQuestionIndex = 0;
    let answers = {}; // { q_0: value, q_1: value, ... }
    const initialShuffles = {}; // Store initial shuffle for ordonner reset
    let evalSegments = [];
    let docColorMap = {};
    let currentDisplayedDocRef = '__none__';

    const DOC_COLORS = ['#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316', '#6366f1', '#10b981', '#e11d48'];
    const PASTILLE_LEVELS = ['facile', 'moyen', 'eleve'];
    const PASTILLE_LABELS = { facile: 'Facile', moyen: 'Moyen', eleve: 'Eleve' };
    let tabSwitchCount = 0;
    let copyPasteCount = 0;
    let rightClickCount = 0;
    let screenshotCount = 0;
    let evalStartTime = null;
    let timerInterval = null;
    let timerRemaining = 0;
    let isSubmitting = false;

    // === MOBILE DETECTION ===
    function isMobile() { return window.innerWidth <= 600; }

    function normalizePastilleNiveau(level) {
        return PASTILLE_LEVELS.includes(level) ? level : null;
    }

    function buildPastilleChip(level, genericLabel) {
        const safeLevel = normalizePastilleNiveau(level);
        if (!safeLevel) return '';
        const label = genericLabel ? 'Pastille' : PASTILLE_LABELS[safeLevel];
        return '<span class="ecm-pastille ecm-pastille-' + safeLevel + '">' +
            '<span class="ecm-pastille-dot"></span>' + label + '</span>';
    }

    function buildPastilleWarningChip(level) {
        const safeLevel = normalizePastilleNiveau(level);
        if (!safeLevel) return '';
        return '<span class="warn-pastille-chip ecm-pastille-' + safeLevel + '">' +
            '<span class="ecm-pastille-dot"></span>Pastille ' + PASTILLE_LABELS[safeLevel] + '</span>';
    }

    // === SCREENS ===
    function showScreen(name) {
        ['screen-login', 'screen-list', 'screen-warning', 'screen-chrono-warning', 'screen-eval', 'screen-results'].forEach(id => {
            document.getElementById(id).classList.add('screen-hidden');
        });
        const target = document.getElementById('screen-' + name);
        target.classList.remove('screen-hidden');
        target.scrollTop = 0;
    }

    // === NORMALIZE TEXT (for mot answers) ===
    function normalizeText(text) {
        return text.trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '');
    }

    // === ESCAPE HTML (security) ===
    function escHtml(str) {
        const div = document.createElement('div');
        div.textContent = str;
        return div.innerHTML;
    }

    // === LOGIN ===
    document.getElementById('login-code').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') doLogin();
    });

    window.doLogin = function() {
        const code = document.getElementById('login-code').value.trim().toUpperCase();
        const errEl = document.getElementById('login-error');

        if (!code) {
            errEl.textContent = 'Entre ton code eleve.';
            errEl.classList.add('visible');
            return;
        }

        // Look up in BDD_ELEVES
        const eleves = window.BDD_ELEVES || [];
        const found = eleves.find(e => e.userCode === code);

        if (!found) {
            errEl.textContent = 'Code inconnu. Verifie ton code eleve.';
            errEl.classList.add('visible');
            return;
        }

        errEl.classList.remove('visible');
        currentUser = found;

        document.getElementById('sb-info').textContent = 'üë§ ' + found.userCode;
        document.getElementById('sb-class').textContent = 'Classe : ' + found.classe;

        showScreen('list');
        loadAvailableEvals();
    };

    window.doLogout = function() {
        // Nettoyer timer si en cours
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        timerRemaining = 0;
        isSubmitting = false;
        currentUser = null;
        currentEval = null;
        currentEvalId = null;
        answers = {};
        tabSwitchCount = 0;
        copyPasteCount = 0;
        rightClickCount = 0;
        screenshotCount = 0;
        showScreen('login');
        document.getElementById('login-code').value = '';
    };

    // === LOAD AVAILABLE EVALS ===
    async function loadAvailableEvals() {
        if (!currentUser) return;
        const container = document.getElementById('eval-list-content');
        container.innerHTML = '<p style="text-align:center; color:#94a3b8;">Chargement...</p>';

        try {
            // Get all published evals (no orderBy to avoid composite index requirement)
            const qEvals = query(collection(db, "eval_banque"), where("publie", "==", true));
            const snap = await getDocs(qEvals);

            const evals = [];
            snap.forEach(d => {
                const data = d.data();
                // Filter by class: support both classeIds (array) and classeId (string) for backward compat
                // PROF bypass: show ALL evals for teacher testing
                const evalClasseIds = data.classeIds || (data.classeId ? [data.classeId] : []);
                if (currentUser.classe === 'PROF' || evalClasseIds.length === 0 || evalClasseIds.includes(currentUser.classe) || evalClasseIds.some(id => isInGroup(id, currentUser.classe))) {
                    evals.push({ id: d.id, ...data });
                }
            });
            // Sort client-side by updatedAt descending
            evals.sort((a, b) => {
                const ta = a.updatedAt?.toMillis ? a.updatedAt.toMillis() : (a.updatedAt || 0);
                const tb = b.updatedAt?.toMillis ? b.updatedAt.toMillis() : (b.updatedAt || 0);
                return tb - ta;
            });

            // Check which ones are already submitted
            const submittedSet = new Set();
            for (const ev of evals) {
                const respDocId = currentUser.userCode + '_' + ev.id;
                const respSnap = await getDoc(doc(db, "eval_reponses", respDocId));
                if (respSnap.exists()) submittedSet.add(ev.id);
            }

            if (evals.length === 0) {
                container.innerHTML = '<div class="eval-list-empty"><div style="font-size:3rem;margin-bottom:12px;">üì≠</div><p>Aucune evaluation disponible pour ta classe.</p></div>';
                return;
            }

            container.innerHTML = '';
            evals.forEach(ev => {
                const isDone = submittedSet.has(ev.id);
                const card = document.createElement('div');
                card.className = 'eval-card' + (isDone ? ' done' : '');
                if (!isDone) {
                    card.onclick = () => startEval(ev.id, ev);
                }

                const qCount = (ev.questions || []).length;
                const timerInfo = ev.timer > 0 ? '<span class="ecm-timer">‚è±Ô∏è ' + ev.timer + ' min</span>' : '';
                const doneInfo = isDone ? '<span class="ecm-done">‚úì Deja fait</span>' : '';
                const evClasseIds = ev.classeIds || (ev.classeId ? [ev.classeId] : []);
                const classeInfo = evClasseIds.length > 0
                    ? '<span class="ecm-classe">üéØ ' + evClasseIds.join(', ') + '</span>'
                    : '<span class="ecm-classe ecm-all">Toutes classes</span>';
                const moduleInfo = ev.moduleId ? '<span class="ecm-module">üìò ' + ev.moduleId + '</span>' : '';
                const pastilleInfo = buildPastilleChip(ev.pastilleNiveau, true);
                const nonNoteInfo = ev.nonNote === true ? '<span class="ecm-module" style="background:rgba(245,158,11,0.15);color:#fcd34d;">üìã Non notee</span>' : '';

                card.innerHTML = '<div class="eval-card-title">' + (ev.titre || 'Evaluation') + '</div>' +
                    '<div class="eval-card-meta">' +
                    classeInfo + moduleInfo + pastilleInfo + nonNoteInfo +
                    '<span class="ecm-questions">' + qCount + ' questions</span>' +
                    '<span class="ecm-bareme">/' + (ev.bareme || 20) + '</span>' +
                    timerInfo + doneInfo + '</div>';
                container.appendChild(card);
            });

        } catch(e) {
            console.error("Erreur chargement evals:", e);
            container.innerHTML = '<p style="text-align:center; color:#ef4444;">Erreur : ' + e.message + '</p>';
        }
    }

    function isInGroup(groupId, classeId) {
        const classes = getClassesFromGroupe(groupId);
        return classes.includes(classeId);
    }

    // === START EVAL ===
    let pendingEvalId = null;
    let pendingEvalData = null;
    window.updateWarningStartButton = function() {
        const checkEl = document.getElementById('warn-pastille-check');
        const blockEl = document.getElementById('warn-pastille-block');
        const startBtn = document.getElementById('warn-start-btn');
        if (!blockEl || !checkEl || !startBtn) return;
        const requiresCheck = blockEl.style.display !== 'none';
        startBtn.disabled = requiresCheck && !checkEl.checked;
    };

    function setupPastilleWarning(evalData) {
        const blockEl = document.getElementById('warn-pastille-block');
        const checkEl = document.getElementById('warn-pastille-check');
        const chipEl = document.getElementById('warn-pastille-chip');
        if (!blockEl || !checkEl || !chipEl) return;

        checkEl.checked = false;
        const safeLevel = normalizePastilleNiveau(evalData ? evalData.pastilleNiveau : null);
        if (!safeLevel) {
            blockEl.style.display = 'none';
            chipEl.innerHTML = '';
            window.updateWarningStartButton();
            return;
        }
        chipEl.innerHTML = buildPastilleWarningChip(safeLevel);
        blockEl.style.display = 'block';
        window.updateWarningStartButton();
    }

    async function startEval(evalId, evalData) {
        // Store pending eval and show warning screen first
        pendingEvalId = evalId;
        pendingEvalData = evalData;
        setupPastilleWarning(evalData);
        showScreen('warning');
    }

    // === CHRONO WARNING (entre anti-triche et lancement) ===
    window.proceedAfterWarning = function() {
        if (pendingEvalData && pendingEvalData.timer > 0) {
            // Chrono actif ‚Üí afficher l'avertissement chrono
            const mins = pendingEvalData.timer;
            document.getElementById('chrono-warn-duree').textContent = mins + ' minute' + (mins > 1 ? 's' : '');
            document.querySelectorAll('.chrono-warn-minutes').forEach(el => { el.textContent = mins; });
            showScreen('chrono-warning');
        } else {
            // Pas de chrono ‚Üí lancer directement
            confirmStartEval();
        }
    };

    window.cancelChronoStart = function() {
        pendingEvalId = null;
        pendingEvalData = null;
        showScreen('list');
    };

    window.confirmStartEval = function() {
        const evalId = pendingEvalId;
        const evalData = pendingEvalData;
        if (!evalId || !evalData) return;

        currentEvalId = evalId;
        currentEval = evalData;
        currentQuestionIndex = 0;
        answers = {};
        tabSwitchCount = 0;
        copyPasteCount = 0;
        rightClickCount = 0;
        screenshotCount = 0;
        isSubmitting = false;
        evalStartTime = Date.now();

        // Protection fermeture onglet pendant l'eval
        window.onbeforeunload = function(e) {
            if (currentEval && !isSubmitting) {
                e.preventDefault();
                e.returnValue = 'Une evaluation est en cours ! Si vous quittez, vos reponses seront perdues.';
                return e.returnValue;
            }
        };

        document.getElementById('et-title').textContent = evalData.titre || 'Evaluation';

        // Compute segments and document colors
        currentDisplayedDocRef = '__none__';
        buildDocColorMap();
        computeSegments();

        // Build nav buttons
        buildNav();
        displayQuestion(0);
        showScreen('eval');

        // Mobile: creer le FAB et ecouter le scroll
        if (isMobile()) {
            createMobileScrollFab();
            var evalBody = document.querySelector('.eval-body');
            if (evalBody) {
                evalBody.addEventListener('scroll', function() {
                    updateFabDirection();
                });
            }
        }

        // Start timer if configured
        if (evalData.timer > 0) {
            timerRemaining = evalData.timer * 60;
            startTimer();
        } else {
            document.getElementById('et-timer').textContent = '';
        }
    };

    // === TIMER ===
    function startTimer() {
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
        updateTimerDisplay();
        timerInterval = setInterval(() => {
            timerRemaining--;
            updateTimerDisplay();
            if (timerRemaining <= 0) {
                clearInterval(timerInterval);
                timerInterval = null;
                submitEval(true);
            }
        }, 1000);
    }

    function updateTimerDisplay() {
        const min = Math.floor(timerRemaining / 60);
        const sec = timerRemaining % 60;
        const el = document.getElementById('et-timer');
        el.textContent = '‚è±Ô∏è ' + min + ':' + (sec < 10 ? '0' : '') + sec;
        if (timerRemaining <= 60) el.style.color = '#ef4444';
        else if (timerRemaining <= 180) el.style.color = '#f59e0b';
        else el.style.color = '#3b82f6';
    }

    // === SEGMENTS ===
    function computeSegments() {
        const qs = currentEval.questions || [];
        evalSegments = [];
        let currentSeg = null;
        qs.forEach((q, i) => {
            const docRef = q.documentRef || null;
            if (!currentSeg || currentSeg.documentRef !== docRef) {
                currentSeg = { documentRef: docRef, startIndex: i, endIndex: i, questionIndices: [i] };
                evalSegments.push(currentSeg);
            } else {
                currentSeg.endIndex = i;
                currentSeg.questionIndices.push(i);
            }
        });
    }

    function buildDocColorMap() {
        docColorMap = {};
        let colorIdx = 0;
        (currentEval.documents || []).forEach(d => {
            docColorMap[d.id] = DOC_COLORS[colorIdx % DOC_COLORS.length];
            colorIdx++;
        });
    }

    function getSegmentForIndex(index) {
        return evalSegments.find(s => index >= s.startIndex && index <= s.endIndex) || null;
    }

    // === NAV ===
    function buildNav() {
        const nav = document.getElementById('eval-nav');
        nav.innerHTML = '';
        const qs = currentEval.questions || [];

        evalSegments.forEach(seg => {
            const group = document.createElement('div');
            group.className = 'nav-group';

            if (seg.documentRef) {
                const docObj = (currentEval.documents || []).find(d => d.id === seg.documentRef);
                const color = docColorMap[seg.documentRef] || '#fbbf24';
                group.classList.add('nav-group-doc');
                group.style.setProperty('--doc-color', color);

                const label = document.createElement('div');
                label.className = 'nav-group-label';
                let labelText = docObj ? docObj.titre : 'Document';
                if (labelText.length > 20) labelText = labelText.substring(0, 18) + '...';
                label.textContent = labelText;
                group.appendChild(label);
            }

            const btnRow = document.createElement('div');
            btnRow.className = 'nav-group-btns';

            seg.questionIndices.forEach(i => {
                const btn = document.createElement('button');
                btn.className = 'nav-btn' + (i === currentQuestionIndex ? ' active' : '') + (answers[qs[i]?.id] !== undefined ? ' answered' : '');
                btn.textContent = (i + 1);
                btn.dataset.qIndex = i;
                btn.onclick = () => { currentQuestionIndex = i; displayQuestion(i); updateNav(); };
                btnRow.appendChild(btn);
            });

            group.appendChild(btnRow);
            nav.appendChild(group);
        });
    }

    function updateNav() {
        const qs = currentEval.questions || [];
        document.querySelectorAll('.nav-btn[data-q-index]').forEach(btn => {
            const i = parseInt(btn.dataset.qIndex);
            btn.className = 'nav-btn' + (i === currentQuestionIndex ? ' active' : '') + (answers[qs[i]?.id] !== undefined ? ' answered' : '');
        });
        updateProgress();
    }

    function updateProgress() {
        const total = (currentEval.questions || []).length;
        const done = Object.keys(answers).length;
        document.getElementById('et-progress').textContent = done + '/' + total + ' repondu(es)';

        // Barre de progression visuelle (mobile)
        const fill = document.getElementById('eval-progress-fill');
        if (fill) fill.style.width = (total > 0 ? (done / total) * 100 : 0) + '%';

        // Show submit button if all answered or on last question
        document.getElementById('btn-submit').style.display = (done >= total || currentQuestionIndex === total - 1) ? 'inline-block' : 'none';

        // Prev/Next buttons
        document.getElementById('btn-prev').disabled = currentQuestionIndex === 0;
        document.getElementById('btn-next').disabled = currentQuestionIndex >= total - 1;
    }

    // === DOCUMENT DISPLAY ===
    function extractYouTubeEmbed(url) {
        if (!url) return null;
        let videoId = null;
        try {
            const u = new URL(url);
            if (u.hostname.includes('youtube.com') && u.searchParams.get('v')) {
                videoId = u.searchParams.get('v');
            } else if (u.hostname === 'youtu.be') {
                videoId = u.pathname.slice(1);
            } else if (u.hostname.includes('youtube.com') && u.pathname.startsWith('/embed/')) {
                videoId = u.pathname.split('/embed/')[1];
            }
        } catch(e) {}
        if (!videoId) {
            const m = url.match(/(?:youtube\.com\/(?:watch\?v=|embed\/)|youtu\.be\/)([a-zA-Z0-9_-]{11})/);
            if (m) videoId = m[1];
        }
        return videoId ? 'https://www.youtube.com/embed/' + videoId : null;
    }

    function updateDocDisplay(index) {
        const qs = currentEval.questions || [];
        const q = qs[index];
        const docRef = q ? (q.documentRef || null) : null;
        const docContainer = document.getElementById('doc-container');
        const qContainer = document.getElementById('question-container');

        console.log('[DOC]', 'Q' + (index + 1), 'docRef:', docRef, 'docs:', (currentEval.documents || []).map(d => d.id));

        if (docRef === currentDisplayedDocRef) return;
        currentDisplayedDocRef = docRef;

        if (!docRef) {
            docContainer.innerHTML = '';
            docContainer.style.display = 'none';
            qContainer.classList.remove('has-doc');
            if (isMobile()) {
                var evalBody = document.querySelector('.eval-body');
                if (evalBody) evalBody.scrollTop = 0;
            }
            updateFabVisibility();
            return;
        }

        const docObj = (currentEval.documents || []).find(d => d.id === docRef);
        if (!docObj) {
            console.warn('[DOC] Document non trouve pour docRef:', docRef);
            docContainer.innerHTML = '';
            docContainer.style.display = 'none';
            qContainer.classList.remove('has-doc');
            updateFabVisibility();
            return;
        }

        const color = docColorMap[docRef] || '#fbbf24';
        const icon = docObj.type === 'image' ? 'üñºÔ∏è' : (docObj.type === 'video' ? 'üé¨' : 'üìÑ');
        const mobile = isMobile();
        // Bouton toggle document (desktop uniquement)
        let html = '';
        if (!mobile) {
            html += '<button class="doc-toggle-btn" onclick="toggleDoc()" style="border-color:' + color + '; color:' + color + ';">' + icon + ' ' + escHtml(docObj.titre) + ' ‚ñº</button>';
        }
        html += '<div class="doc-display' + (mobile ? '' : ' doc-collapsed') + '" style="border-color:' + color + ';">';
        html += '<h4 style="color:' + color + ';">' + icon + ' ' + escHtml(docObj.titre) + '</h4>';
        if (docObj.type === 'image') {
            const imgUrl = docObj.content || '';
            if (/^https?:\/\//.test(imgUrl)) {
                html += '<img src="' + imgUrl + '" alt="' + escHtml(docObj.alt || docObj.titre) + '" onerror="this.outerHTML=\'<div class=doc-img-placeholder>üì∑ Image non disponible</div>\'" style="max-width:100%; max-height:35vh; object-fit:contain; border-radius:8px; margin-top:8px;">';
            } else {
                html += '<div class="doc-img-placeholder">üì∑ URL image invalide</div>';
            }
            if (docObj.description || docObj.credit) {
                html += '<div class="doc-caption" style="font-size:0.8rem; color:#94a3b8; margin-top:6px;">';
                if (docObj.description) html += escHtml(docObj.description);
                if (docObj.credit) html += (docObj.description ? ' ‚Äî ' : '') + 'Cr√©dit : ' + escHtml(docObj.credit);
                html += '</div>';
            }
        } else if (docObj.type === 'video') {
            const embedUrl = extractYouTubeEmbed(docObj.content);
            if (embedUrl) {
                // Wrapper padding-bottom 16:9 (compatible tous navigateurs)
                html += '<div style="position:relative; padding-bottom:56.25%; height:0; overflow:hidden; border-radius:8px; margin-top:8px;">';
                html += '<iframe src="' + embedUrl + '" allowfullscreen style="position:absolute; top:0; left:0; width:100%; height:100%; border:none;"></iframe>';
                html += '</div>';
            } else {
                html += '<div class="doc-text" style="color:#dc2626;">URL video invalide</div>';
            }
        } else {
            html += '<div class="doc-text">' + escHtml(docObj.content || '').replace(/\n/g, '<br>') + '</div>';
        }
        // Render description if present (text docs)
        if (docObj.type !== 'image' && docObj.description) {
            html += '<div class="doc-text" style="margin-top:10px; padding-top:10px; border-top:1px solid #fde68a;">' + escHtml(docObj.description) + '</div>';
        }
        html += '</div>';

        docContainer.innerHTML = html;
        docContainer.style.display = 'block';
        qContainer.classList.add('has-doc');
        // Mobile: scroll au top quand le document change
        if (mobile) {
            var evalBody = document.querySelector('.eval-body');
            if (evalBody) evalBody.scrollTop = 0;
        }
        updateFabVisibility();
    }

    // === TOGGLE DOCUMENT (desktop uniquement) ===
    window.toggleDoc = function() {
        if (isMobile()) return; // Sur mobile, le document est toujours en flux continu
        const display = document.querySelector('#doc-container .doc-display');
        const btn = document.querySelector('#doc-container .doc-toggle-btn');
        if (!display || !btn) return;
        display.classList.toggle('doc-collapsed');
        btn.textContent = btn.textContent.replace(/[‚ñº‚ñ≤]/, display.classList.contains('doc-collapsed') ? '‚ñº' : '‚ñ≤');
    };

    // === MOBILE : BOUTON FLOTTANT (FAB) DOCUMENT/QUESTIONS ===
    var mobileScrollFab = null;
    var fabMode = 'questions'; // 'questions' ou 'document'

    function createMobileScrollFab() {
        if (mobileScrollFab) return;
        mobileScrollFab = document.createElement('button');
        mobileScrollFab.className = 'mobile-scroll-fab';
        mobileScrollFab.textContent = '\u2193'; // fl√®che bas
        mobileScrollFab.setAttribute('aria-label', 'Aller aux questions');
        mobileScrollFab.onclick = function() {
            var target;
            if (fabMode === 'questions') {
                target = document.getElementById('question-container');
            } else {
                target = document.getElementById('doc-container');
            }
            if (target) smoothScrollTo(target);
        };
        document.getElementById('screen-eval').appendChild(mobileScrollFab);
    }

    function updateFabVisibility() {
        if (!mobileScrollFab) return;
        if (!isMobile() || !currentEval) {
            mobileScrollFab.classList.remove('fab-visible');
            return;
        }
        var docContainer = document.getElementById('doc-container');
        if (!docContainer || docContainer.style.display === 'none' || docContainer.innerHTML === '') {
            mobileScrollFab.classList.remove('fab-visible');
            return;
        }
        mobileScrollFab.classList.add('fab-visible');
    }

    function updateFabDirection() {
        if (!mobileScrollFab || !isMobile()) return;
        var evalBody = document.querySelector('.eval-body');
        var qContainer = document.getElementById('question-container');
        if (!evalBody || !qContainer) return;
        var bodyRect = evalBody.getBoundingClientRect();
        var qRect = qContainer.getBoundingClientRect();
        var midpoint = bodyRect.top + bodyRect.height / 2;
        if (qRect.top > midpoint) {
            fabMode = 'questions';
            mobileScrollFab.textContent = '\u2193'; // fl√®che bas
            mobileScrollFab.setAttribute('aria-label', 'Aller aux questions');
        } else {
            fabMode = 'document';
            mobileScrollFab.textContent = '\u2191'; // fl√®che haut
            mobileScrollFab.setAttribute('aria-label', 'Retour au document');
        }
    }

    function smoothScrollTo(element) {
        var evalBody = document.querySelector('.eval-body');
        if (!evalBody || !element) return;
        try {
            element.scrollIntoView({ behavior: 'smooth', block: 'start' });
        } catch(e) {
            // Fallback pour vieux navigateurs : animation manuelle
            var targetTop = element.offsetTop - evalBody.offsetTop;
            var startTop = evalBody.scrollTop;
            var distance = targetTop - startTop;
            var duration = 400;
            var startTime = null;
            function step(timestamp) {
                if (!startTime) startTime = timestamp;
                var elapsed = timestamp - startTime;
                var progress = Math.min(elapsed / duration, 1);
                var eased = progress * (2 - progress); // ease-out quad
                evalBody.scrollTop = startTop + distance * eased;
                if (progress < 1) requestAnimationFrame(step);
            }
            if (typeof requestAnimationFrame !== 'undefined') {
                requestAnimationFrame(step);
            } else {
                element.scrollIntoView(true);
            }
        }
    }

    // === DISPLAY QUESTION ===
    function displayQuestion(index) {
        const qs = currentEval.questions || [];
        const q = qs[index];
        if (!q) return;

        // Update persistent document display
        updateDocDisplay(index);

        const container = document.getElementById('question-container');
        let html = '';

        // Section badge for document-linked questions
        const seg = getSegmentForIndex(index);
        if (seg && seg.documentRef) {
            const docObj = (currentEval.documents || []).find(d => d.id === seg.documentRef);
            const posInSeg = seg.questionIndices.indexOf(index) + 1;
            const totalInSeg = seg.questionIndices.length;
            const color = docColorMap[seg.documentRef] || '#fbbf24';
            const docTitle = docObj ? escHtml(docObj.titre) : 'Document';
            html += '<div class="q-section-badge" style="border-left-color:' + color + ';">Question ' + posInSeg + ' sur ' + totalInSeg + ' ‚Äî ' + docTitle + '</div>';
        }

        html += '<div class="q-number">Question ' + (index + 1) + ' / ' + qs.length;
        if (q.competence) html += '<span class="q-comp-badge">' + escHtml(q.competence) + '</span>';
        html += '</div>';
        html += '<div class="q-text">' + escHtml(q.question) + '</div>';

        const currentAnswer = answers[q.id];

        if (q.type === 'qcm_single') {
            (q.choices || []).forEach((choice, ci) => {
                const checked = currentAnswer === ci ? ' checked' : '';
                const selected = currentAnswer === ci ? ' selected' : '';
                html += '<div class="answer-option' + selected + '" onclick="selectRadio(\'' + q.id + '\', ' + ci + ')">' +
                    '<input type="radio" name="ans-' + q.id + '" value="' + ci + '"' + checked + '> ' + escHtml(choice) + '</div>';
            });
        } else if (q.type === 'qcm_multi') {
            html += '<div class="q-multi-hint">Plusieurs reponses possibles ‚Äî coche toutes les bonnes reponses.</div>';
            (q.choices || []).forEach((choice, ci) => {
                const isChecked = Array.isArray(currentAnswer) && currentAnswer.includes(ci);
                const checked = isChecked ? ' checked' : '';
                const selected = isChecked ? ' selected' : '';
                html += '<div class="answer-option' + selected + '" onclick="toggleCheck(\'' + q.id + '\', ' + ci + ')">' +
                    '<input type="checkbox" name="ans-' + q.id + '" value="' + ci + '"' + checked + '> ' + escHtml(choice) + '</div>';
            });
        } else if (q.type === 'vf') {
            const selTrue = currentAnswer === true ? ' selected-true' : '';
            const selFalse = currentAnswer === false ? ' selected-false' : '';
            html += '<div class="vf-options">' +
                '<div class="vf-option' + selTrue + '" onclick="selectVF(\'' + q.id + '\', true)">Vrai</div>' +
                '<div class="vf-option' + selFalse + '" onclick="selectVF(\'' + q.id + '\', false)">Faux</div>' +
                '</div>';
        } else if (q.type === 'mot') {
            html += '<input type="text" class="text-answer" id="input-mot" placeholder="Ta reponse..." value="' + escHtml(currentAnswer || '') + '" oninput="setMotAnswer(\'' + q.id + '\', this.value)">';
            html += '<div class="info-text" style="margin-top:8px;">Ecris le mot correctement (accents et majuscules toleres).</div>';
        } else if (q.type === 'nombre') {
            html += '<input type="number" class="text-answer number-answer" id="input-nombre" placeholder="Ta reponse..." value="' + (currentAnswer !== undefined ? currentAnswer : '') + '" step="any" oninput="setNombreAnswer(\'' + q.id + '\', this.value)">';
        } else if (q.type === 'ordonner') {
            let currentOrder = currentAnswer;
            if (!currentOrder) {
                currentOrder = (q.items || []).map((_, i) => i);
                // Fisher-Yates shuffle
                for (let i = currentOrder.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [currentOrder[i], currentOrder[j]] = [currentOrder[j], currentOrder[i]];
                }
                answers[q.id] = currentOrder;
                initialShuffles[q.id] = [...currentOrder];
            }
            html += '<div class="ord-list" id="ord-list-' + q.id + '">';
            const n = (q.items || []).length;
            currentOrder.forEach((itemIdx, rank) => {
                let options = '';
                for (let r = 0; r < n; r++) {
                    options += '<option value="' + r + '"' + (r === rank ? ' selected' : '') + '>' + (r + 1) + '</option>';
                }
                html += '<div class="ord-item" data-idx="' + itemIdx + '">' +
                    '<div class="ord-select">' +
                        '<select id="ord-sel-' + q.id + '-' + itemIdx + '" ' +
                            'onchange="window.setOrdRank(\'' + q.id + '\',' + itemIdx + ',parseInt(this.value,10))">' +
                            options +
                        '</select>' +
                    '</div>' +
                    '<span class="ord-text">' + escHtml((q.items || [])[itemIdx]) + '</span>' +
                '</div>';
            });
            html += '</div>';
            html += '<button type="button" class="ord-reset-btn" onclick="window.resetOrdItem(\'' + q.id + '\')">üîÑ Remelanger</button>';
        }

        container.innerHTML = html;
        updateProgress();
    }

    // === ANSWER HANDLERS ===
    window.selectRadio = function(qId, value) {
        answers[qId] = value;
        displayQuestion(currentQuestionIndex); // refresh visual
        updateNav();
    };

    window.toggleCheck = function(qId, value) {
        if (!Array.isArray(answers[qId])) answers[qId] = [];
        const idx = answers[qId].indexOf(value);
        if (idx >= 0) {
            answers[qId].splice(idx, 1);
            if (answers[qId].length === 0) delete answers[qId];
        } else {
            answers[qId].push(value);
        }
        displayQuestion(currentQuestionIndex);
        updateNav();
    };

    window.selectVF = function(qId, value) {
        answers[qId] = value;
        displayQuestion(currentQuestionIndex);
        updateNav();
    };

    window.setMotAnswer = function(qId, value) {
        if (value.trim()) answers[qId] = value.trim();
        else delete answers[qId];
        updateNav();
    };

    window.setNombreAnswer = function(qId, value) {
        const num = parseFloat(value);
        if (value !== '' && !isNaN(num)) answers[qId] = num;
        else delete answers[qId];
        updateNav();
    };

    // === ORDONNER HANDLERS ===
    window.setOrdRank = function(qId, itemIdx, newRank) {
        const order = answers[qId];
        if (!Array.isArray(order)) return;
        if (newRank < 0 || newRank >= order.length) return;
        const oldRank = order.indexOf(itemIdx);
        if (oldRank === -1 || oldRank === newRank) return;
        // Swap automatique : l'item qui occupait newRank prend oldRank
        const displacedItem = order[newRank];
        order[newRank] = itemIdx;
        order[oldRank] = displacedItem;
        answers[qId] = order;
        displayQuestion(currentQuestionIndex);
        updateNav();
    };

    window.resetOrdItem = function(qId) {
        if (initialShuffles[qId]) {
            answers[qId] = [...initialShuffles[qId]];
        }
        displayQuestion(currentQuestionIndex);
        updateNav();
    };

    window.prevQ = function() {
        if (currentQuestionIndex > 0) {
            currentQuestionIndex--;
            displayQuestion(currentQuestionIndex);
            updateNav();
        }
    };

    window.nextQ = function() {
        const total = (currentEval.questions || []).length;
        if (currentQuestionIndex < total - 1) {
            currentQuestionIndex++;
            displayQuestion(currentQuestionIndex);
            updateNav();
        }
    };

    // === SUBMIT EVAL ===
    window.submitEval = async function(forceAutoSubmit) {
        // Anti double-soumission
        if (isSubmitting) return;

        const total = (currentEval.questions || []).length;
        const answered = Object.keys(answers).length;

        if (forceAutoSubmit) {
            // Chrono ecoule ‚Üí envoi force, pas de confirmation
            alert('‚è±Ô∏è Temps ecoule !\n\nVotre copie a ete envoyee automatiquement.\n(' + answered + '/' + total + ' questions repondues)');
        } else if (answered < total) {
            if (!confirm('Tu n\'as repondu qu\'a ' + answered + '/' + total + ' questions. Soumettre quand meme ?')) return;
        } else {
            if (!confirm('Es-tu sur de vouloir soumettre ? Tu ne pourras plus modifier tes reponses.')) return;
        }

        isSubmitting = true;
        if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

        const tempsSecondes = Math.round((Date.now() - evalStartTime) / 1000);

        // 1. Run auto-correction
        const correctionResult = autoCorrect(currentEval, answers);

        // 2. Save raw answers to eval_reponses
        try {
            const respDocId = currentUser.userCode + '_' + currentEvalId;
            await setDoc(doc(db, "eval_reponses", respDocId), {
                eleveCode: currentUser.userCode,
                evalId: currentEvalId,
                classe: currentUser.classe,
                reponses: answers,
                submittedAt: new Date().toISOString(),
                tabSwitchCount,
                copyPasteCount,
                rightClickCount,
                screenshotCount,
                tempsSecondes
            });
        } catch(e) {
            console.error("Erreur envoi eval_reponses:", e);
        }

        // 3. Write notes + copies to resultats (ne bloque pas l'affichage)
        try {
            await writeResults(currentUser.userCode, currentEvalId, currentEval, correctionResult, tempsSecondes);
        } catch(e) {
            console.warn("Erreur writeResults:", e.message);
        }

        // Desactiver la protection fermeture (copie envoyee)
        window.onbeforeunload = null;

        // 4. TOUJOURS afficher les resultats a l'eleve (meme si Firebase a eu un souci)
        showResults(correctionResult);
    };

    // === AUTO-CORRECTION ENGINE ===
    function autoCorrect(evalData, studentAnswers) {
        const results = { questions: {}, competences: {}, totalPoints: 0, totalMax: 0 };
        const qs = evalData.questions || [];

        qs.forEach(q => {
            const studentAnswer = studentAnswers[q.id];
            let isCorrect = false;
            let earnedPoints = 0;

            if (studentAnswer === undefined || studentAnswer === null || studentAnswer === '') {
                // Not answered
                results.questions[q.id] = { level: 'NT', earnedPoints: 0, maxPoints: q.points || 0, studentAnswer: null, isCorrect: false };
                results.totalMax += (q.points || 0);
                if (q.competence) {
                    if (!results.competences[q.competence]) results.competences[q.competence] = { pts: 0, max: 0 };
                    results.competences[q.competence].max += (q.points || 0);
                }
                return;
            }

            switch (q.type) {
                case 'qcm_single':
                    isCorrect = studentAnswer === q.correct;
                    break;
                case 'qcm_multi':
                    const correctSet = new Set(q.correct || []);
                    const answerSet = new Set(studentAnswer || []);
                    isCorrect = correctSet.size === answerSet.size && [...correctSet].every(c => answerSet.has(c));
                    break;
                case 'vf':
                    isCorrect = studentAnswer === q.correct;
                    break;
                case 'mot':
                    isCorrect = normalizeText(String(studentAnswer)) === normalizeText(String(q.correct || q.reponse || ''));
                    break;
                case 'nombre':
                    const tolerance = q.tolerance || 0;
                    isCorrect = Math.abs(parseFloat(studentAnswer) - parseFloat(q.correct)) <= tolerance;
                    break;
                case 'ordonner':
                    if (Array.isArray(studentAnswer) && Array.isArray(q.correct) && studentAnswer.length === q.correct.length) {
                        let nbBienPlaces = 0;
                        studentAnswer.forEach((v, i) => { if (v === q.correct[i]) nbBienPlaces++; });
                        const ratio = nbBienPlaces / q.correct.length;
                        earnedPoints = Math.round((q.points || 0) * ratio * 100) / 100;
                        isCorrect = (nbBienPlaces === q.correct.length);
                    }
                    break;
            }

            // Don't overwrite ordonner's partial earnedPoints
            if (q.type !== 'ordonner') {
                earnedPoints = isCorrect ? (q.points || 0) : 0;
            }
            const level = isCorrect ? 'M' : 'I';

            results.questions[q.id] = { level, earnedPoints, maxPoints: q.points || 0, studentAnswer, isCorrect };
            results.totalPoints += earnedPoints;
            results.totalMax += (q.points || 0);

            if (q.competence) {
                if (!results.competences[q.competence]) results.competences[q.competence] = { pts: 0, max: 0 };
                results.competences[q.competence].pts += earnedPoints;
                results.competences[q.competence].max += (q.points || 0);
            }
        });

        // Final note
        results.note = results.totalMax > 0
            ? Math.round((results.totalPoints / results.totalMax) * (currentEval.bareme || 20) * 2) / 2
            : 0;
        results.bareme = currentEval.bareme || 20;

        return results;
    }

    // === WRITE RESULTS TO FIREBASE (for resultats.html integration) ===
    async function writeResults(eleveCode, evalId, evalData, correction, tempsSecondes) {
        const now = new Date().toISOString();
        const qs = evalData.questions || [];

        // Build blueprint for detail view in resultats.html
        const blueprintContent = qs.map((q, i) => {
            let reponseAttendue = '';
            if (q.type === 'qcm_single') reponseAttendue = (q.choices || [])[q.correct] || '';
            else if (q.type === 'qcm_multi') reponseAttendue = (q.correct || []).map(c => (q.choices || [])[c]).join(', ');
            else if (q.type === 'vf') reponseAttendue = q.correct ? 'Vrai' : 'Faux';
            else if (q.type === 'mot') reponseAttendue = q.correct || q.reponse || '';
            else if (q.type === 'nombre') reponseAttendue = String(q.correct) + (q.tolerance ? ' (¬± ' + q.tolerance + ')' : '');
            else if (q.type === 'ordonner') reponseAttendue = (q.correct || []).map(i => (q.items || [])[i]).join(' ‚Üí ');

            return {
                type: 'question',
                qid: q.id,
                label: 'Q' + (i + 1),
                question: q.question,
                competence: q.competence,
                bareme: q.points,
                reponseAttendue,
                correction: q.correction || '',
                explication: q.explication || ''
            };
        });

        // Build questions map for resultats.html format
        const questionsMap = {};
        qs.forEach((q, i) => {
            const result = correction.questions[q.id];
            questionsMap['q_' + i] = {
                level: result ? result.level : 'NT',
                comment: q.correction || ''
            };
        });

        // Build human-readable reponses for copy doc (resultats.html display)
        const reponsesSimple = {};
        qs.forEach(q => {
            const raw = answers[q.id];
            if (raw === undefined || raw === null) {
                reponsesSimple[q.id] = null;
                return;
            }
            // Convert indices to readable text for resultats.html
            if (q.type === 'qcm_single') {
                reponsesSimple[q.id] = (q.choices || [])[raw] || String(raw);
            } else if (q.type === 'qcm_multi') {
                reponsesSimple[q.id] = (Array.isArray(raw) ? raw : []).map(i => (q.choices || [])[i] || String(i)).join(', ');
            } else if (q.type === 'vf') {
                reponsesSimple[q.id] = raw === true ? 'Vrai' : 'Faux';
            } else {
                reponsesSimple[q.id] = String(raw);
            }
        });

        // 1. Write COPY document (non critique ‚Äî ne bloque pas les notes)
        try {
            await setDoc(doc(db, "resultats", eleveCode, "copies", evalId + '_autoeval'), {
                eleveCode,
                devoirId: evalId,
                titre: 'Auto-evaluation : ' + (evalData.titre || 'Evaluation'),
                createdAtISO: now,
                eleve: { userCode: eleveCode, classe: currentUser.classe },
                reponses: reponsesSimple,
                source: 'auto_eval',
                temps_secondes: tempsSecondes
            });
        } catch(e) {
            console.warn('[COPIES] Erreur ecriture copie (non critique):', e.message);
        }

        // 2. Write EVALUATION document (CRITIQUE ‚Äî contient les notes et competences)
        const evalDoc = {
            eleveCode,
            devoirId: evalId,
            titre: 'Auto-evaluation : ' + (evalData.titre || 'Evaluation'),
            note_finale: correction.note,
            appreciation: 'Auto-correction automatique. Note : ' + correction.note + '/' + correction.bareme,
            publie: false, // Will be published by teacher
            autocorrected: true,
            source: 'auto_eval',
            competences: correction.competences,
            questions: questionsMap,
            blueprint: {
                titre: 'Auto-evaluation : ' + (evalData.titre || 'Evaluation'),
                content: blueprintContent
            },
            savedAt: now,
            savedBy: 'auto_correction'
        };
        if (evalData.nonNote === true) evalDoc.nonNote = true;
        await setDoc(doc(db, "resultats", eleveCode, "evaluations", evalId + '_eval'), evalDoc);
    }

    // === SHOW RESULTS ===
    function showResults(correction) {
        const container = document.getElementById('results-container');
        const qs = currentEval.questions || [];
        const isNonNote = currentEval.nonNote === true;
        const isCorrDifferee = currentEval.correctionDifferee === true;
        const isCorrPubliee = currentEval.correctionPubliee === true;
        let html = '';

        // Determine if we should show detailed correction
        // Non not√© ‚Üí always show full correction (formative)
        // Not√© + correction imm√©diate ‚Üí show correction
        // Not√© + correction diff√©r√©e ‚Üí only if prof published correction
        const showCorrection = isNonNote || (!isCorrDifferee) || (isCorrDifferee && isCorrPubliee);

        // Score card (always shown, except for non-not√© where we show a different message)
        if (isNonNote) {
            html += '<div class="score-card">' +
                '<div class="score-big score-ok">üìã Exercice formatif</div>' +
                '<div class="score-label">' + correction.totalPoints + ' points sur ' + correction.totalMax + '</div>' +
                '</div>';
        } else {
            const pct = correction.bareme > 0 ? (correction.note / correction.bareme) * 100 : 0;
            const scoreClass = pct >= 60 ? 'score-ok' : pct >= 40 ? 'score-mid' : 'score-low';
            html += '<div class="score-card">' +
                '<div class="score-big ' + scoreClass + '">' + correction.note + ' / ' + correction.bareme + '</div>' +
                '<div class="score-label">' + correction.totalPoints + ' points sur ' + correction.totalMax + '</div>' +
                '</div>';
        }

        // Competences card (always shown)
        const compEntries = Object.entries(correction.competences);
        if (compEntries.length > 0) {
            html += '<div class="comps-card"><h3>üéØ Competences</h3>';
            compEntries.forEach(([compId, comp]) => {
                const compPct = comp.max > 0 ? (comp.pts / comp.max) * 100 : 0;
                let level = 'NT';
                if (compPct >= 80) level = 'M';
                else if (compPct >= 50) level = 'A';
                else if (compPct > 0) level = 'I';
                const levelLabels = { M: 'Maitrise', A: 'Acquis', I: 'En cours', NT: 'Non travaille' };
                html += '<div class="comp-row">' +
                    '<span class="comp-name">' + compId + '</span>' +
                    '<span>' + comp.pts + '/' + comp.max + ' pts</span>' +
                    '<span class="comp-badge cb-' + level + '">' + levelLabels[level] + '</span>' +
                    '</div>';
            });
            html += '</div>';
        }

        // Detail per question ‚Äî only if correction is allowed
        if (showCorrection) {
            html += '<h3 style="margin:16px 0 12px; font-size:1.1rem;">üìù Detail des reponses</h3>';
            qs.forEach((q, i) => {
                const result = correction.questions[q.id] || { level: 'NT', isCorrect: false, studentAnswer: null };
                const cardClass = result.level === 'NT' ? 'unanswered' : (result.isCorrect ? 'correct' : 'incorrect');
                const resultLabel = result.level === 'NT' ? 'Non repondu' : (result.isCorrect ? '‚úÖ Correct' : '‚ùå Incorrect');
                const resultClass = result.level === 'NT' ? '' : (result.isCorrect ? 'dc-correct' : 'dc-incorrect');

                html += '<div class="detail-card ' + cardClass + '">';
                html += '<div class="dc-header"><span class="dc-num">Q' + (i + 1) + (q.competence ? ' ‚Äî ' + q.competence : '') + '</span><span class="dc-result ' + resultClass + '">' + resultLabel + ' (' + (result.earnedPoints || 0) + '/' + (q.points || 0) + ' pts)</span></div>';
                html += '<div class="dc-question">' + q.question + '</div>';

                // Your answer
                if (result.studentAnswer !== null && result.studentAnswer !== undefined) {
                    let yourText = formatAnswer(q, result.studentAnswer);
                    html += '<div class="dc-answer-block dc-your"><div class="dc-label">‚úçÔ∏è Ta reponse :</div>' + yourText + '</div>';
                }

                // Correct answer
                let goodText = formatCorrectAnswer(q);
                html += '<div class="dc-answer-block dc-good"><div class="dc-label">‚úÖ Bonne reponse :</div>' + goodText + '</div>';

                // Correction
                if (q.correction) {
                    html += '<div class="dc-answer-block dc-correction"><div class="dc-label">üìù Correction :</div>' + q.correction + '</div>';
                }

                // Explication
                if (q.explication) {
                    html += '<div class="dc-answer-block dc-explication"><div class="dc-label">üí° Explication :</div>' + q.explication + '</div>';
                }

                html += '</div>';
            });
        } else {
            // Not√© + correction diff√©r√©e non publi√©e ‚Üí message d'attente
            html += '<div style="text-align:center; padding:24px; margin:16px 0; background:rgba(59,130,246,0.1); border-radius:12px; border:1px solid rgba(59,130,246,0.3);">' +
                '<div style="font-size:2rem; margin-bottom:8px;">üîí</div>' +
                '<p style="color:#93c5fd; font-size:1rem; margin:0;">La correction sera disponible apres publication par ton professeur.</p>' +
                '</div>';
        }

        // Mapse link
        html += '<div class="mapse-link">Retrouve toutes tes ressources et resultats sur <a href="https://mapse.fr" target="_blank">mapse.fr</a></div>';

        container.innerHTML = html;
        showScreen('results');
        window.scrollTo(0, 0);
    }

    function formatAnswer(q, answer) {
        if (q.type === 'qcm_single') return (q.choices || [])[answer] || '?';
        if (q.type === 'qcm_multi') return (answer || []).map(i => (q.choices || [])[i]).join(', ') || '?';
        if (q.type === 'vf') return answer ? 'Vrai' : 'Faux';
        if (q.type === 'mot') return String(answer);
        if (q.type === 'nombre') return String(answer);
        if (q.type === 'ordonner') return (answer || []).map(i => (q.items || [])[i]).join(' ‚Üí ');
        return String(answer);
    }

    function formatCorrectAnswer(q) {
        if (q.type === 'qcm_single') return (q.choices || [])[q.correct] || '?';
        if (q.type === 'qcm_multi') return (q.correct || []).map(i => (q.choices || [])[i]).join(', ') || '?';
        if (q.type === 'vf') return q.correct ? 'Vrai' : 'Faux';
        if (q.type === 'mot') return q.correct || q.reponse || '?';
        if (q.type === 'nombre') return String(q.correct) + (q.tolerance ? ' (¬± ' + q.tolerance + ')' : '');
        if (q.type === 'ordonner') return (q.correct || []).map(i => (q.items || [])[i]).join(' ‚Üí ');
        return '?';
    }

    // === ANTI-CHEAT: Tab switch detection ===
    document.addEventListener('visibilitychange', () => {
        if (!currentEval || !currentUser) return;

        if (document.hidden) {
            tabSwitchCount++;
        } else {
            const alertEl = document.getElementById('alert-tabswitch');
            if (tabSwitchCount === 1) {
                document.getElementById('alert-count-msg').textContent = 'Ne quittez pas cette page pendant l\'evaluation.';
            } else {
                document.getElementById('alert-count-msg').textContent = 'Sortie(s) detectee(s) : ' + tabSwitchCount;
            }
            alertEl.style.display = 'flex';
            setTimeout(() => { alertEl.style.display = 'none'; }, 2000);
        }
    });

    // === ANTI-CHEAT: Copy/Paste/Cut detection + BLOCAGE ===
    ['copy', 'paste', 'cut'].forEach(evt => {
        document.addEventListener(evt, (e) => {
            if (!currentEval || !currentUser) return;
            e.preventDefault();
            copyPasteCount++;
            const alertEl = document.getElementById('alert-tabswitch');
            document.getElementById('alert-count-msg').textContent = 'Copier/coller BLOQUE ! (' + copyPasteCount + ' tentative' + (copyPasteCount > 1 ? 's' : '') + ')';
            alertEl.style.display = 'flex';
            setTimeout(() => { alertEl.style.display = 'none'; }, 2000);
        });
    });

    // === ANTI-CHEAT: Right-click prevention ===
    document.addEventListener('contextmenu', (e) => {
        if (!currentEval || !currentUser) return;
        e.preventDefault();
        rightClickCount++;
    });

    // === ANTI-CHEAT: Drag prevention ===
    document.addEventListener('dragstart', (e) => {
        if (!currentEval || !currentUser) return;
        e.preventDefault();
    });

    // === ANTI-CHEAT: Screenshot detection (PrintScreen / raccourcis) ===
    document.addEventListener('keyup', (e) => {
        if (!currentEval || !currentUser) return;
        // PrintScreen (Windows), Cmd+Shift+3/4 (Mac), Ctrl+Shift+S
        if (e.key === 'PrintScreen' ||
            (e.key === 's' && e.ctrlKey && e.shiftKey) ||
            (e.key === '3' && e.metaKey && e.shiftKey) ||
            (e.key === '4' && e.metaKey && e.shiftKey)) {
            screenshotCount++;
            const alertEl = document.getElementById('alert-tabswitch');
            document.getElementById('alert-count-msg').textContent = 'Capture d\'ecran detectee ! (' + screenshotCount + ')';
            alertEl.style.display = 'flex';
            setTimeout(() => { alertEl.style.display = 'none'; }, 3000);
        }
    });
</script>
</body>
</html>
